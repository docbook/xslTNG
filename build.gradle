buildscript {
  repositories {
    mavenLocal()
    mavenCentral()
    maven { url "https://dev.saxonica.com/maven" }
  }

  apply from: 'properties.gradle'

  configurations.all {
    resolutionStrategy {
      force 'xml-apis:xml-apis:1.4.01',
        "${saxonGroup}:${saxonEdition}:${saxonVersion}",
        "org.xmlresolver:xmlresolver:${xmlresolverVersion}"
    }
  }

  dependencies {
    classpath group: saxonGroup, name: saxonEdition, version: saxonVersion
    classpath group: 'com.drewnoakes', name: 'metadata-extractor', version: metadataExtractorVersion
    classpath group: 'com.nwalsh', name: 'sinclude', version: sincludeVersion
    classpath group: 'org.xmlresolver', name: 'xmlresolver', version: xmlresolverVersion
    classpath group: 'org.docbook', name: 'schemas-docbook', version: docbookVersion
    classpath group: 'org.docbook', name: 'schemas-publishers', version: docbookVersion
  }
}

plugins {
  id "java"
  id "groovy"
  id "maven-publish"
  id "signing"
  id 'com.nwalsh.gradle.saxon.saxon-gradle' version '0.10.0'
  id 'com.nwalsh.gradle.relaxng.validate' version '0.0.6'
  id 'com.nwalsh.gradle.relaxng.translate' version '0.0.6'
  id "de.undercouch.download" version "4.0.4"
}

sourceCompatibility=1.8
targetCompatibility=1.8

sourceSets {
  main {
    java {
      srcDirs = ['src/main/java']
    }
  }
}

import com.nwalsh.gradle.saxon.SaxonXsltTask
import com.nwalsh.gradle.relaxng.validate.RelaxNGValidateTask
import com.nwalsh.gradle.relaxng.translate.RelaxNGTranslateTask
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.security.MessageDigest
import java.time.Instant
import java.time.format.DateTimeFormatter

import de.undercouch.gradle.tasks.download.Download

repositories {
  mavenLocal()
  mavenCentral()
  maven { url "https://dev.saxonica.com/maven" }
}

apply from: 'properties.gradle'

configurations.all {
  resolutionStrategy {
    force 'xml-apis:xml-apis:1.4.01',
      "${saxonGroup}:${saxonEdition}:${saxonVersion}",
      "org.xmlresolver:xmlresolver:${xmlresolverVersion}"
  }
}

configurations {
  validateRuntime.extendsFrom(testImplementation)
  projectImplementationClasspath.extendsFrom(implementation)
  projectRuntimeClasspath.extendsFrom(runtimeOnly)
}

ext {
  requireCompileSuccess = !"false".equals(project.property('requireCompileSuccess'))
  epubMediaTypes = [
    "css": "text/css",
    "ttf": "font/ttf",
    "woff": "font/woff",
    "jpg": "image/jpeg",
    "jpeg": "image/jpeg",
    "png": "image/png",
    "gif": "image/gif",
    "svg": "image/svg"
  ]
  computedGitRef = null
}

// Set saxonLicenseDir in gradle.properties, or from the
// command line if you have a license in some other place.
if (!hasProperty("saxonLicenseDir")) {
  if (System.getenv("SAXON_LICENSE_DIR") != null) {
    ext.saxonLicenseDir=System.getenv('SAXON_LICENSE_DIR')
  } else {
    ext.saxonLicenseDir=System.getenv('HOME') + "/java"
  }
}

dependencies {
  implementation (
    [group: saxonGroup, name: saxonEdition, version: saxonVersion],
    [group: 'com.drewnoakes', name: 'metadata-extractor', version: metadataExtractorVersion],
    [group: 'org.relaxng', name: 'jing', version: jingVersion ],
    [group: 'org.relaxng', name: 'trang', version: jingVersion ],
    [group: 'org.xmlresolver', name: 'xmlresolver', version: xmlresolverVersion],
    [group: 'com.nwalsh', name: 'sinclude', version: sincludeVersion ],
    files("${projectDir}/buildSrc/build/classes/java/main"),
    files(saxonLicenseDir)
  )
  testImplementation (
    [group: 'junit', name: 'junit', version: '4.13'],
    [group: 'org.docbook', name: 'schemas-docbook', version: docbookVersion],
    [group: 'org.docbook', name: 'schemas-publishers', version: docbookVersion]
  )
}

defaultTasks 'report'

def docbookXsltArgs = ['-init:org.docbook.xsltng.extensions.Register']

relaxng_validate.configure {
  classpath configurations.validateRuntime
}

// If this is running on the CI infrastructure and it's not
// a tagged build, add -SNAPSHOT to the version.
if (System.getenv()["CIWORKFLOW"] == "yes"
    && System.getenv()["CI_TAG"] == ""
    && !xslTNGversion.contains('SNAPSHOT')) {
  xslTNGversion = xslTNGversion + "-SNAPSHOT"
}

// These are the top-level XSpec test drivers
def testDrivers = ['docbook.xspec', 'main.xspec', '00_logstruct.xspec',
                   '20_db4to5.xspec', 'local_conventions.xspec',
                   'transclude.xspec']

// I'm not sure I want to generate *all* the PDF files.
// This is a kind of random list...
def pdfTests = ['article.003', 'book.001', 'book.003',
                'calloutlist.001', 'changebars.001', 'mediaobject.001'];

class SummarizeTestResults extends DefaultTask {
  @Input
  String[] resultFiles = []

  @TaskAction
  def docheck() {
    resultFiles.each { driver ->
      def base = driver.substring(0, driver.length() - 6)
      println(base)
    }
  }
}

class CheckTextFile extends DefaultTask {
  @Input
  String checkFile = null

  @TaskAction
  def docheck() {
    def pass = true
    new File(checkFile).eachLine { line ->
      if (line.endsWith("failed") && !line.equals("0 failed")) {
        pass = false
      }
      println(line)
    }
    if (!pass) {
      throw new GradleException("Failing tests!")
    }
  }
}

def gitRef() {
  // Depending on the state of your repo, this can be time consuming,
  // so don't bother unless you're demanding complete success...
  if (computedGitRef != null) {
    return computedGitRef
  }

  def ref = null;
  if (requireCompileSuccess) {
    def gitRepo = new File(".git")
    if (gitRepo.exists() && gitRepo.isDirectory()) {
      def command = ['git', 'rev-parse', '--short', '--verify', 'HEAD']
      ProcessBuilder pb = new ProcessBuilder().command(command)
      pb.directory(projectDir)
      Process proc = pb.start()

      def reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
      String line = null
      while ((line = reader.readLine()) != null) {
        if (ref == null) {
          ref = line
        }
      }

      reader = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
      while ((line = reader.readLine()) != null) {
        println(line)
      }

      proc.waitFor()
    }
  } else {
    ref = "SNAPSHOT"
  }

  computedGitRef = ref
  
  if (ref == null) {
    ref = "Unknown"
    println("This doesn't appear to be a git clone; using VERSION-ID: ${ref}")
  } else {
    println("Using git ref as VERSION-ID: ${ref}")
  }

  return ref
}

import static groovy.io.FileType.DIRECTORIES
def pygmentize = findPygmentize()
def findPygmentize() {
  def path = System.getenv()["PATH"]
  def script = null
  path.split(":+").each { segment ->
    if (script == null) {
      def testfile = new File("${segment}/pygmentize")
      if (testfile.exists() && testfile.canExecute()) {
        script = testfile.toString()
      }

      if (segment.endsWith("/.pyenv/shims")) {
        // Ok, we found pyenv, now can we find pygmentize?
        def pyenv = new File("${segment.substring(0, segment.length() - 6)}/versions")
        def versions = []
        pyenv.traverse(type: DIRECTORIES, maxDepth: 0) { dir ->
          testfile = new File("${dir}/bin/pygmentize")
          if (testfile.exists() && testfile.canExecute()) {
            script = testfile.toString()
          }
        }
      }
    }
  }

  if (script == null) {
    println("Could not find pygmentize")
    script = "" // nevermind
  } else {
    println("Using Pygments from ${script}")
  }

  return script
}

// This is all a complete hack that I worked out by trial and error
def EXCP="${projectDir}/build/classes/java/main"
configurations.compileClasspath.each { it ->
  EXCP += ":" + it
}

// Set system properties
System.setProperty("org.docbook.xsltng.extensions.verbose", verbose)
System.setProperty("org.docbook.extensions.pygmentize", pygmentize)

println("Using Java version ${System.getProperty('java.version')}")

task configureEnvironment() {
  def envVars = [:]
  envVars['TEST_DIR'] = buildDir
  envVars['SAXON_CP'] = EXCP
  envVars['PYGMENTIZE'] = pygmentize
  envVars['VERBOSE'] = verbose
  tasks.withType(Exec) {
    environment << envVars
  }
}

task setupXSpec(type: Download) {
  src "https://github.com/xspec/xspec/archive/v${xspecVersion}.zip"
  dest file("${buildDir}/xspec-${xspecVersion}.zip")
  doFirst {
    mkdir(buildDir)
  }
  doLast {
    copy {
      from zipTree("${buildDir}/xspec-${xspecVersion}.zip")
      into buildDir
    }
  }
  doLast {
    copy {
      from "${projectDir}/src/test/resources/xspec"
      into "${buildDir}/xspec-${xspecVersion}/src/common"
      include "uri-utils.xsl"
    }
  }
  doLast {
    copy {
      from "${projectDir}/src/test/resources/xspec"
      into "${buildDir}/xspec-${xspecVersion}/bin"
      include "xspec.sh"
    }
  }
  onlyIf { !file("${buildDir}/xspec-${xspecVersion}/README.md").exists() }
}

task setupXsltExplorer(type: Download) {
  outputs.file "${buildDir}/xsltexplorer-${xsltExplorerVersion}/xslt/explorer.xsl"

  src "https://github.com/ndw/xsltexplorer/releases/download/${xsltExplorerVersion}/xsltexplorer-${xsltExplorerVersion}.zip"
  dest file("${buildDir}/xsltexplorer-${xsltExplorerVersion}.zip")
  doFirst {
    mkdir(buildDir)
  }
  doLast {
    copy {
      from zipTree("${buildDir}/xsltexplorer-${xsltExplorerVersion}.zip")
      into buildDir
    }
  }

  onlyIf { !file("${buildDir}/xsltexplorer-${xsltExplorerVersion}/README.org").exists() }
}

task copyResources(type: Copy,
                   dependsOn: ['copyTestMedia', 'zipStageResources',
                               'zipStageMisc']) {
  from "${buildDir}/stage/zip/resources"
  into "${buildDir}/actual"
}

def pkglist = ["net.sf.saxon:Saxon-HE:${saxonVersion}",
               "com.drewnoakes:metadata-extractor:${metadataExtractorVersion}",
               "org.relaxng:jing:${jingVersion}",
               "org.xmlresolver:xmlresolver:${xmlresolverVersion}",
               "com.nwalsh:sinclude:${sincludeVersion}"]

task copyBin(type: Copy) {
  def packages = ""
  pkglist.each { pkg ->
    if (packages != "") {
      packages += ",\n                          "
    }
    packages = packages + "\"${pkg}\""
  }

  from "${projectDir}/src/bin"
  into "${buildDir}/bin"
  rename("docbook.py", "docbook")
  filter { String line ->
    if (line.indexOf("@@") >= 0) {
      line = line
        .replace("\"@@PACKAGE_LIST@@\"", packages)
        .replace("@@VERSION@@", xslTNGversion)
    }
    line
  }
}

task copyDocker(type: Copy) {
  def commands = ""
  pkglist.each { pkg ->
    commands += "RUN mvn org.apache.maven.plugins:maven-dependency-plugin:2.4:get \\\n"
    commands += "        -Dartifact=${pkg}\n"
  }

  from "${projectDir}/src/docker"
  into "${buildDir}/docker"
  filter { String line ->
    if (line.indexOf("@@") >= 0) {
      line = line
        .replace("@@MAVEN-COMMANDS@@", commands)
        .replace("@@VERSION@@", xslTNGversion)
    }
    line
  }
}

task copyReportResources(type: Copy,
                         dependsOn: ['copyReportSources',
                                     'copyExpectedResources',
                                     'copyReportImages',
                                     'copyExpectedGeneratedResources']) {
  from "${projectDir}/src/test/resources"
  include "css/**"
  include "js/**"
  into "${buildDir}/report"
  filter { String line ->
    if (line.indexOf("@@") >= 0) {
      line = line
        .replace("@@TITLE@@", xslTNGtitle)
        .replace("@@VERSION@@", xslTNGversion)
    }
    line
  }
}

task copyReportImages(type: Copy) {
  from "${projectDir}/src/website/resources"
  include "img/**"
  include "media/**"
  exclude "olinkdb/**"
  into "${buildDir}/report"
}

task copyReportSources(type: Copy) {
  from "${projectDir}/src/test/resources"
  include "xml/**"
  include "expected/**"
  filter { String line ->
    if (line.indexOf("@@") >= 0) {
      line = line
        .replace("@@TITLE@@", xslTNGtitle)
        .replace("@@VERSION@@", xslTNGversion)
    }
    line
  }
  into "${buildDir}/report"
}

task copyExpectedResources(type: Copy, dependsOn: ['copyExpectedMedia', 'zipStageResources',
                                                   'zipStageMisc']) {
  from "${buildDir}/stage/zip/resources"
  into "${buildDir}/report/expected"
}

task copyExpectedGeneratedResources(type: Copy, dependsOn: ['generateXSpecSources']) {
  from "${buildDir}/generated-xml"
  into "${buildDir}/report/xml"
}

task copyTestMedia(type: Copy) {
  from "${projectDir}/src/test/resources"
  into "${buildDir}/actual"
  include "media/**"
}

task copyExpectedMedia(type: Copy) {
  from "${projectDir}/src/test/resources"
  into "${buildDir}/report/expected"
  include "media/**"
}

task allExpectedDocuments() {
  // Just something to hang dependencies on
}

task allExpectedPdfDocuments() {
  // Just something to hang dependencies on
}

task reportExpectedHTML() {
  // Just something to hang dependencies on
}

task validateAll() {
  // Just something to hang dependencies on
}

task generateLocales() {
  // Just something to hang dependencies on
}

// Generate tasks to run each set of XSpec tests
def elementTests = [:]
def copiedXSpecTasks = []
fileTree(dir: "${projectDir}/src/test/xspec").each { xspec ->
  // Work out the base filename of the test
  def base = xspec.toString()
  def pos = base.indexOf("/test/xspec/")
  if (pos > 0) {
    base = base.substring(pos+12)
    base = base.replace(".xspec", "")
  }

  def taskname = null;

  if (base.startsWith("generated-")) {
    // Ignore these; they're dealt with separately
  } else {
    def copytaskname = "copy_" + base.replace("-", "_") + ".xspec"
    Task t = task "${copytaskname}"(
      type: SaxonXsltTask,
      dependsOn: ['makeXslt']
    ) {
      input xspec
      stylesheet "${projectDir}/tools/copy-xspec.xsl"
      output "${buildDir}/xspec/${base}.xspec"
      args docbookXsltArgs 
    }
    copiedXSpecTasks << t

    taskname = base.replace("-", "_") + ".xspec"
    t = task "${taskname}"(
      type: Exec,
      dependsOn: ['setupXSpec', 'makeXslt', copytaskname]
    ) {
      inputs.files fileTree(dir: "${projectDir}/src/main/xslt")
      inputs.files fileTree(dir: "${projectDir}/src/test/xspec")
      inputs.files fileTree(dir: "${projectDir}/src/test/resources")
      inputs.files "${buildDir}/xspec/${base}.xspec"
      outputs.file file("${buildDir}/${base}-compiled.xsl")
      outputs.file file("${buildDir}/${base}-result.html")
      outputs.file file("${buildDir}/${base}-result.xml")
      commandLine "${buildDir}/xspec-${xspecVersion}/bin/xspec.sh",
                  "${buildDir}/xspec/${base}.xspec"
    }
  }

  // If the XSpec file enumerates the elements it tests,
  // construct tests for those elements
  def xspecTaskName = taskname
  def xspecFilename = xspec.toString().substring(projectDir.toString().length() + 1)
  def elemList = false
  xspec.eachLine { line ->
    elemList = elemList && !line.contains("-->")
    if (elemList) {
      line.trim().split("\\s+").each { tag ->
        if (elementTests.get(tag)) {
          elementTests[tag].push(xspecFilename)
        } else {
          def speclist = [xspecFilename]
          elementTests[tag] = speclist
        }
      }
    }

    elemList = elemList || line.startsWith("<!-- Tests:")
  }
}

// Now the docbook.xspec task exists
copiedXSpecTasks.each { task ->
  testDrivers.each { driver ->
    tasks.findByName(driver).dependsOn task
  }
}

def xspecTestDir = new File(buildDir, "elemtest")
if (!xspecTestDir.exists()) {
  if (!buildDir.exists()) {
    buildDir.mkdir()
  }
  xspecTestDir.mkdir()
}
elementTests.keySet().each { tag ->
  File xspec = new File(xspecTestDir, tag + ".xspec")
    .withWriter("utf-8") { writer ->
      writer.writeLine('<?xml version="1.0" encoding="UTF-8"?>')
      writer.writeLine('<x:description xmlns:x="http://www.jenitennison.com/xslt/xspec"')
      writer.writeLine('               stylesheet="../xslt/docbook.xsl">')
      writer.writeLine('')
      elementTests[tag].each { test ->
        writer.writeLine("<x:import href='../../" + test + "'/>")
      }
      writer.writeLine("</x:description>")
    }

  def xspecTask = task "${tag}Test"(type: Exec, dependsOn:
                                    ['setupXSpec', 'copyResources']) {
    inputs.files fileTree(dir: "${projectDir}/src/main/xslt")
    inputs.files fileTree(dir: "${projectDir}/src/test/xspec")
    inputs.files fileTree(dir: "${projectDir}/src/test/resources")
    outputs.files(fileTree(buildDir) {
      include tag + "Test-result.xml"
    })
    commandLine "${buildDir}/xspec-${xspecVersion}/bin/xspec.sh",
                "${buildDir}/elemtest/${tag}.xspec"
    }
}

// Generate tasks to construct the generated tests
fileTree(dir: "${projectDir}/src/test/generators").each { xsl ->
  def xspec = xsl.toString()
                 .replace("/generators/", "/xspec/generated-")
                 .replace(".xsl", ".xspec")
  def name  = xspec.replace(".xspec", "")
                 .replace("/", "_")
                 .replace(".", "_")
                 .replace("-", "_")

  // Shorten the name a little if possible
  def pos = name.indexOf("generated_")
  if (pos > 0) {
    name = name.substring(pos)
  }

  // Work out the base filename of the test
  def base = xspec
  pos = base.indexOf("/test/xspec/")
  if (pos > 0) {
    base = base.substring(pos+12)
    base = base.replace(".xspec", "")
  }

  def generator = name + "_gen"
  def taskname = name + "XSpec"

  Task g = task "${generator}"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt']
  ) {
    input xsl
    stylesheet xsl
    output "${buildDir}/xspec/${base}.xspec"
  }

  Task t = task "${taskname}"(
    type: Exec,
    dependsOn: ['setupXSpec', 'makeXslt']
  ) {
    inputs.files fileTree(dir: "${projectDir}/src/main/xslt")
    inputs.files fileTree(dir: "${projectDir}/src/test/xspec")
    inputs.files fileTree(dir: "${projectDir}/src/test/resources")
    outputs.files(fileTree(buildDir) {
      include base + "-result.xml"
    })
    commandLine "${buildDir}/xspec-${xspecVersion}/bin/xspec.sh",
                "${buildDir}/xspec/${base}.xspec"
  }
  
  t.dependsOn g
  testDrivers.each { driver ->
    tasks.findByName(driver).dependsOn g
  }
}

task actualResults() {
  // Just somewhere to hang dependencies
}

// Generate tasks to format each resource/xml document
fileTree(dir: "${projectDir}/src/test/resources/xml",
         include: "*.xml",
         exclude: "tran-caution.xml").each { xml ->
  // Work out the base filename of the test
  def base = xml.toString()
  def pos = base.indexOf("/resources/xml/")
  if (pos > 0) {
    base = base.substring(pos+15)
      .replace("/", "_")
      .replace(".xml", "")
  }

  def stylesheetParams = [:]

  if (base == 'bibliography.003') {
    stylesheetParams['bibliography-collection'] = "${projectDir}/src/test/resources/bibcollection.xml"
  }

  if (base == 'glossary.002') {
    stylesheetParams['glossary-collection'] = "${projectDir}/src/test/resources/glosscollection.xml"
  }

  if (base == 'annotations.004') {
    stylesheetParams['annotation-collection'] = "${projectDir}/src/test/resources/anncollection.xml"
  }

  if (base == 'profiling.001') {
    stylesheetParams['profile-os'] = 'win;linux'
  }

  if (base == "fit.001" || base == "fit.002") {
    stylesheetParams['profile-outputformat'] = 'online'
  }

  if (base.startsWith('remark.')) {
    stylesheetParams['show-remarks'] = true
  }

  if (base.startsWith('colors.')) {
    stylesheetParams['show-remarks'] = true
    stylesheetParams['theme-picker'] = true
    stylesheetParams['persistent-toc'] = true
  }

  if (base.startsWith('ptoc.')) {
    stylesheetParams['persistent-toc'] = true
  }

  if (base.startsWith('local.')) {
    stylesheetParams['local-conventions'] = "${projectDir}/src/test/resources/local.xsl"
    stylesheetParams['relax-ng-grammar'] = "${projectDir}/src/test/resources/docbook.rng"
  }

  if (base.startsWith("olink.")) {
    def dirs = ["${buildDir}/actual/guide.olinkdb",
                "${buildDir}/actual/fit.001.olinkdb",
                "${buildDir}/actual/fit.002.olinkdb",
                "${projectDir}/src/website/resources/olinkdb/website.olinkdb"]
    stylesheetParams['olink-databases'] = dirs.join(",")
  }

  def schemaFn = "${projectDir}/src/test/resources/docbook.rng"
  if (base.contains("xinclude") || base.contains('iso690')
      || base == "fit.001" || base == "fit.002") {
    schemaFn = "${projectDir}/src/test/resources/docbookxi.rng"
  }

  if (base.contains('transclusion')) {
    schemaFn = "${projectDir}/src/test/resources/transclude.rng"
    stylesheetParams['docbook-transclusion'] = 'true'
  }

  if (publishersDocuments.contains(base)) {
    schemaFn = "${projectDir}/src/test/resources/publishers.rng"
  }

  Task t = null
  def htmlDependsOn = ['makeXslt']
  if (base.startsWith("local.")) {
    t = task "validate_${base}"() {
      doLast {
        println("Not validating ${base}")
      }
    }
  } else {
    t = task "validate_${base}"(type: RelaxNGValidateTask) {
      input xml
      output "${buildDir}/validated/${base}"
      schema schemaFn
      idref !invalidIdrefDocuments.contains(base)
    }
    validateAll.dependsOn t
    htmlDependsOn.push("validate_${base}")
  }

  t = task "${base}.html"(type: SaxonXsltTask, dependsOn: htmlDependsOn) {
    inputs.files fileTree(dir: "${buildDir}/xslt")
    inputs.files fileTree(dir: "${projectDir}/src/test/resources")
    inputs.file file("${buildDir}/xslt/docbook.xsl")

    stylesheetParams['mediaobject-output-base-uri'] = "media/"
    stylesheetParams['mediaobject-output-paths'] = "false"
    stylesheetParams['dynamic-profiles'] = true

    //println("Task ${base}.html: ${stylesheetParams}")

    input xml
    stylesheet "${buildDir}/xslt/docbook.xsl"
    output "${buildDir}/actual/${base}.html"
    args docbookXsltArgs 
    parameters(stylesheetParams)
  }
  actualResults.dependsOn t

  if (base.startsWith("colors.")) {
    // disable for expected results
    stylesheetParams = [:]
  }

  t = task "${base}.expected"(type: SaxonXsltTask, dependsOn: htmlDependsOn) {
    inputs.files fileTree(dir: "${projectDir}/src/main/xslt")
    inputs.files fileTree(dir: "${projectDir}/src/test/resources", exclude: 'expected')
    inputs.file file("${buildDir}/xslt/xspec-driver.xsl")

    stylesheetParams['dynamic-profiles'] = true

    input xml
    stylesheet "${buildDir}/xslt/xspec-driver.xsl"
    output "${projectDir}/src/test/resources/expected/${base}.html"
    args docbookXsltArgs 
    parameters(stylesheetParams)
  }
  allExpectedDocuments.dependsOn t

  if (base == "fit.001" || base == "fit.002") {
    stylesheetParams = [:]
    stylesheetParams['chunk'] = 'index.html'
    stylesheetParams['chunk-output-base-uri'] = 'https://xsltng.docbook.org/samples/fit/'
  }

  t = task "${base}.olinkdb"(type: SaxonXsltTask, dependsOn: htmlDependsOn) {
    inputs.files fileTree(dir: "${projectDir}/src/main/xslt")
    inputs.files fileTree(dir: "${projectDir}/src/test/resources", exclude: "expected")
    inputs.file file("${buildDir}/xslt/olinkdb.xsl")

    stylesheetParams['dynamic-profiles'] = true
    stylesheetParams['olink-targetdoc'] = base

    //println("Task ${base}.olinkdb: ${stylesheetParams}")

    input xml
    stylesheet "${buildDir}/xslt/olinkdb.xsl"
    output "${buildDir}/actual/${base}.olinkdb"
    args docbookXsltArgs 
    parameters(stylesheetParams)
  }

  stylesheetParams = [:]

  if (base == "fit.001" || base == "fit.002") {
    stylesheetParams['annotation-style'] = 'javascript'
    stylesheetParams['profile-outputformat'] = 'online'
    stylesheetParams['persistent-toc'] = true
  }

  if (base.startsWith("colors.")) {
    stylesheetParams['show-remarks'] = true
    stylesheetParams['theme-picker'] = true
    stylesheetParams['persistent-toc'] = true
  }

  if (base.startsWith('ptoc.')) {
    stylesheetParams['persistent-toc'] = true
  }

  t = task "${base}.chunk"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', "validate_${base}"]
  ) {
    inputs.files fileTree(dir: "${projectDir}/src/main/xslt")
    inputs.files fileTree(dir: "${projectDir}/src/test/resources")
    inputs.file file("${buildDir}/xslt/docbook.xsl")
    outputs.files fileTree(dir: "${buildDir}/actual", include: "**/*.html")

    stylesheetParams['chunk'] = 'index.html'
    stylesheetParams['chunk-output-base-uri'] = "${buildDir}/actual/"
    stylesheetParams['dynamic-profiles'] = true

    input xml
    stylesheet "${buildDir}/xslt/docbook.xsl"
    args docbookXsltArgs 
    parameters(stylesheetParams)
  }

  stylesheetParams = [:]

  stylesheetParams['profile-outputformat'] = 'print'

  if (base.startsWith("book.")) {
    stylesheetParams['page-style'] = 'book'
  }

  t = task "${base}.pdf.html"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', "validate_${base}"]
  ) {
    inputs.files fileTree(dir: "${projectDir}/src/main/xslt")
    inputs.files fileTree(dir: "${projectDir}/src/test/resources")
    inputs.file "${buildDir}/xslt/print.xsl"

    stylesheetParams['resource-base-uri'] = ''
    stylesheetParams['dynamic-profiles'] = true

    input xml
    stylesheet "${buildDir}/xslt/print.xsl"
    output "${buildDir}/actual/${base}.pdf.html"
    args docbookXsltArgs 
    parameters(stylesheetParams)
  }

  if (pdftool == "prince") {
    t = task "${base}.pdf"(type: Exec,
                          dependsOn: ["${base}.pdf.html"]) {
      inputs.files fileTree(dir: "${buildDir}/actual/css")
      inputs.file("${buildDir}/actual/${base}.pdf.html")
      outputs.file("${buildDir}/actual/${base}.pdf")
      commandLine "${prince}",
        "${buildDir}/actual/${base}.pdf.html",
        "-o", "${buildDir}/actual/${base}.pdf"
    }
    t = task "${base}.pdf.expected"(type: Exec,
                          dependsOn: ["${base}.pdf.html"]) {
      inputs.files fileTree(dir: "${buildDir}/actual/css")
      inputs.file("${buildDir}/actual/${base}.pdf.html")
      outputs.file("${projectDir}/src/test/resources/expectedpdf/${pdftool}/${base}.pdf")
      commandLine "${prince}",
        "${buildDir}/actual/${base}.pdf.html",
        "-o", "${projectDir}/src/test/resources/expectedpdf/${pdftool}/${base}.pdf"
    }
  } else {
    t = task "${base}.pdf"(type: Exec,
                          dependsOn: ["${base}.pdf.html"]) {
      inputs.files fileTree(dir: "${buildDir}/actual/css")
      inputs.file("${buildDir}/actual/${base}.pdf.html")
      outputs.file("${buildDir}/actual/${base}.pdf")
      commandLine "${antennahouse}",
        "-d", "${buildDir}/actual/${base}.pdf.html",
        "-o", "${buildDir}/actual/${base}.pdf"
    }
    t = task "${base}.pdf.expected"(type: Exec,
                          dependsOn: ["${base}.pdf.html"]) {
      inputs.files fileTree(dir: "${buildDir}/actual/css")
      inputs.file("${buildDir}/actual/${base}.pdf.html")
      outputs.file("${projectDir}/src/test/resources/expectedpdf/${pdftool}/${base}.pdf")
      commandLine "${antennahouse}",
        "-d", "${buildDir}/actual/${base}.pdf.html",
        "-o", "${projectDir}/src/test/resources/expectedpdf/${pdftool}/${base}.pdf"
    }
  }
}

// Now that we have the html olink targets
tasks.findByName("docbook.xspec").dependsOn "fit.001.olinkdb"
tasks.findByName("docbook.xspec").dependsOn "fit.002.olinkdb"
tasks.findByName("docbook.xspec").dependsOn "guide.olinkdb"

fileTree(dir: "${projectDir}/src/test/resources/xml", include: "*.xml").each { xml ->
  // Work out the base filename of the test
  def base = xml.toString()
  def pos = base.indexOf("/resources/xml/")
  if (pos > 0) {
    base = base.substring(pos+15)
      .replace("/", "_")
      .replace(".xml", "")
  }
  if (base.startsWith("olink.")) {
    Task t = tasks.findByName("${base}.html")
    t.dependsOn "fit.001.olinkdb"
    t.dependsOn "fit.002.olinkdb"
    t.dependsOn "guide.olinkdb"

    t = tasks.findByName("${base}.expected")
    t.dependsOn "fit.001.olinkdb"
    t.dependsOn "fit.002.olinkdb"
    t.dependsOn "guide.olinkdb"
  }
}

// Now that we have the PDF tasks...
pdfTests.each { basename ->
  Task t = tasks.findByName("${basename}.pdf.expected")
  allExpectedPdfDocuments.dependsOn t
}

// ============================================================

task generateXSpecSources() {
  // Just something to hang dependencies on
}
testDrivers.each { driver ->
  tasks.findByName(driver).dependsOn generateXSpecSources
  tasks.findByName(driver).dependsOn "makeXslt"
}

// Generate programlistingco/screeco results with all the possible stylings
["programlistingco.001", "screenco.001"].each { source ->
  ["raw", "plain", "lines"].each { style ->
    ["true", "false"].each { numbered ->
      ["linecolumn", "lines", "lineranges-all", "lineranges-first",
       "linecolumn,lines",
       "linecolumn,lineranges-all",
       "linecolumn,lineranges-first",
       "linecolumn,lines,lineranges-all",
       "linecolumn,lines,lineranges-first",
       "lines,lineranges-all",
       "lines,lineranges-first"].each { highlight ->
        def S = style.substring(0, 1).toLowerCase() + "_"
        def N = numbered.substring(0, 1).toLowerCase() + "_"
        def H = ""

        if (highlight == "linecolumn")                             H = "lc"
        else if (highlight == "lines")                             H = "l"
        else if (highlight == "lineranges-all")                    H = "lra"
        else if (highlight == "lineranges-first")                  H = "lrf"
        else if (highlight == "linecolumn,lines")                  H = "lc-l"
        else if (highlight == "linecolumn,lineranges-all")         H = "lc-lra"
        else if (highlight == "linecolumn,lineranges-first")       H = "lc-lrf"
        else if (highlight == "linecolumn,lines,lineranges-all")   H = "lc-l-lra"
        else if (highlight == "linecolumn,lines,lineranges-first") H = "lc-l-lrf"
        else if (highlight == "lines,lineranges-all")              H = "l-lra"
        else if (highlight == "lines,lineranges-first")            H = "l-lrf"
        else H = "X"

        def basename = "${source}_${S}${N}${H}"

        Task g = task "generate_${basename}.xml"(type: SaxonXsltTask) {
          inputs.file("${projectDir}/src/test/resources/xml/${source}.xml")
          inputs.file("${projectDir}/tools/generate-co.xsl")

          input "${projectDir}/src/test/resources/xml/${source}.xml"
          stylesheet "${projectDir}/tools/generate-co.xsl"
          output "${buildDir}/generated-xml/${basename}.xml"

          parameters (
            "style": style,
            "highlight": highlight,
            "numbered": numbered,
            "everyNth": 5,
            "minlines": 5,
            "first": true
          )
        }
        generateXSpecSources.dependsOn g

        Task t = task "${basename}.html"(
          type: SaxonXsltTask, dependsOn: ['makeXslt']
        ) {
          input "${buildDir}/generated-xml/${basename}.xml"
          stylesheet "${buildDir}/xslt/docbook.xsl"
          output "${buildDir}/actual/${basename}.html"
          args docbookXsltArgs 
        }
        t.dependsOn g
        tasks.findByName("${source}.html").dependsOn t

        t = task "${basename}.expected"(
          type: SaxonXsltTask,
          dependsOn: ['makeXslt']
        ) {
          input "${buildDir}/generated-xml/${basename}.xml"
          stylesheet "${buildDir}/xslt/xspec-driver.xsl"
          output "${projectDir}/src/test/resources/expected/${basename}.html"
          args docbookXsltArgs 
          parameters(
            'xspec-expected': 1,
          )
        }
        t.dependsOn g
        tasks.findByName("${source}.expected").dependsOn t
      }
    }
  }
}

// ============================================================

// Generate tasks to generate the locale files
fileTree(dir: "${projectDir}/src/main/locale", include: "*.xml").each { xml ->
  // Work out the base filename of the test
  def base = xml.toString()
  def pos = base.lastIndexOf("/")
  if (pos > 0) {
    base = base.substring(pos+1)
  }

  Task t = task "locale_${base}"(
    type: SaxonXsltTask
  ) {
    input xml
    stylesheet "${projectDir}/src/main/xslt/modules/xform-locale.xsl"
    output "${buildDir}/xslt/locale/${base}"

    if (base != 'en.xml') {
      parameters(
        'fallback.locale': "${projectDir}/src/main/locale/en.xml"
      )
    }
  }
  generateLocales.dependsOn t
}

task makeVersion(type: SaxonXsltTask) {
  input "${projectDir}/tools/version.xsl"
  stylesheet "${projectDir}/tools/version.xsl"
  output "${buildDir}/xslt/VERSION.xsl"
  parameters(
    'version': xslTNGversion,
    'gitref': gitRef()
  )
}

task copyXslt(type: Copy,
              dependsOn: ['copyResources', 'makeVersion',
                          'generateLocales', 'compileJava']) {
  from "${projectDir}/src/main/xslt"
  into "${buildDir}/xslt"
  exclude "param.xsl"
}

task makeXslt(type: SaxonXsltTask, dependsOn: ["copyXslt"]) {
  input "${projectDir}/src/guide/xml/ref-params.xml"
  stylesheet "${projectDir}/tools/generate-parameters.xsl"
  output "${buildDir}/xslt/param.xsl"
}

task makeUriList(
  dependsOn: ["makeXslt", "zipStageResources","zipStageDocker",
              "zipStageXslt", "zipStageBin"]
) {
  inputs.files fileTree("${buildDir}/xslt")
  inputs.files fileTree("${buildDir}/stage/zip")
  outputs.file "${buildDir}/resources/main/org/docbook/xsltng/etc/uris.xml"

  doFirst {
    mkdir "${buildDir}/resources/main/org/docbook/xsltng/etc"
  }

  doLast {
    def prefix = '/org/docbook/xsltng'
    new File("${buildDir}/resources/main/org/docbook/xsltng/etc/uris.xml").withWriter("utf-8") { writer ->
      writer.writeLine("<catalog>")

      def pos = "${buildDir}".length()
      fileTree("${buildDir}/xslt").each { file ->
        writer.writeLine("  <uri name='${prefix}${file.getAbsolutePath().substring(pos)}'/>")
      }

      pos = "${buildDir}/stage/zip".length()
      fileTree("${buildDir}/stage/zip/resources").each { file ->
        writer.writeLine("  <uri name='${prefix}${file.getAbsolutePath().substring(pos)}'/>")
      }
      writer.writeLine("</catalog>")
    }
  }
}

// ============================================================

task formattingTests() {
  // Just somewhere to hang dependencies. I used to put these
  // dependencies directly on 'test', but that had the consequence
  // that running a single unit test ran all of the formatting
  // tests.
}

task testJarMain(type: Exec, dependsOn: jar) {
    commandLine "java",
      "-jar", "${buildDir}/libs/docbook-xslTNG-${xslTNGversion}.jar",
      "${projectDir}/src/test/resources/xml/article.001.xml",
      "-o:/dev/null"
}
formattingTests.dependsOn testJarMain

task testDocBookPy(type: Exec, dependsOn: ["jar", "copyBin", "copyDocker"]) {
    commandLine "${buildDir}/bin/docbook",
      "${projectDir}/src/test/resources/xml/article.001.xml",
      "-xsl:build/xslt/docbook.xsl",
      "-o:/dev/null"
}
formattingTests.dependsOn testDocBookPy

task testConsoleSummary(type: SummarizeTestResults, dependsOn: testDrivers) {
  resultFiles = testDrivers
}

task testSummary(type: SaxonXsltTask, dependsOn: testDrivers) {
  input file("${buildDir}/docbook-result.xml")
  stylesheet file("${projectDir}/tools/test-results.xsl")
  output "${buildDir}/test-results.txt"
  parameters (
    "test-drivers": testDrivers.join(" ")
  )
}

task requirePassingTests(
  type: CheckTextFile,
  dependsOn: ['formattingTests', 'testSummary']) {
  checkFile = "${buildDir}/test-results.txt"
}
test.dependsOn requirePassingTests

task reportResults(type: Copy, dependsOn: ['testSummary']) {
  from "build"
  include "*-result.*"
  include "*-compiled.xsl"
  into "${buildDir}/report"
}

task coverageReport(type: SaxonXsltTask,
                    dependsOn: ['testSummary', 'copyReportResources']) {
  input "${buildDir}/docbook-result.xml"
  stylesheet "${projectDir}/tools/coverage-report.xsl"
  output "${buildDir}/report/coverage-report.html"
  parameters (
    "test-drivers": testDrivers.join(" ")
  )
}
formattingTests.dependsOn reportResults
formattingTests.dependsOn coverageReport

// Use Exec so that it runs the same version of Saxon as the tests.
task report(type: Exec,
            dependsOn: ['copyReportResources',
                        'reportExpectedHTML',
                        'coverageReport', 'reportResults']) {
  inputs.file("${buildDir}/docbook-result.xml")
  inputs.file("${projectDir}/tools/report.xsl")
  outputs.file("${buildDir}/report/index.html")
  commandLine "java",
    "-Dorg.docbook.xsltng.extensions.verbose=${verbose}",
    "-Dorg.docbook.extensions.pygmentize=${pygmentize}",
    "-cp", EXCP, "net.sf.saxon.Transform",
    "-init:org.docbook.xsltng.extensions.Register",
    "${buildDir}/docbook-result.xml",
    "-xsl:tools/report.xsl",
    "-o:${buildDir}/report/index.html",
    "test-drivers=${testDrivers.join(' ')}"
}

// ============================================================
// The mediaobject tests 
// Test 1 and 2 are "the same" except for the arrangement of
// the source files.
task all_mo_tests(
  group: "mediaobject-test",
  description: "Run all the mo-/n/ mediaobject tests"
) {
  // Just somewhere to hang dependencies
}

["1", "2"].each { mo ->
  Task t = task "mo_${mo}_test_1"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 1"
  ) {
    // Single output HTML file, media all in the same relative locations

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-1"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-1"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-1"
        from "${projectDir}/src/test/resources/xml/mo-${mo}"
        include "**/*"
        exclude "**/*.xml"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-1"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    output "${buildDir}/actual/mo-${mo}-1/index.html"
    args docbookXsltArgs 
    /*
    parameters([
      "debug": "mediaobject-uris"
    ])
     */

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-1"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_2"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 2"
  ) {
    // Single output HTML file, media all in a common directory

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-2"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-2"
    }

    doFirst {
      // N.B. These copy commands are a bit redundant because they
      // have to work for all of the input layouts
      copy {
        into "${buildDir}/actual/mo-${mo}-2/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-2/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/body"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-2/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/front"
        include "*.mp4"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-2/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-2"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    output "${buildDir}/actual/mo-${mo}-2/index.html"
    args docbookXsltArgs 
    parameters([
      "mediaobject-output-base-uri": "media/",
      "mediaobject-output-paths": "false"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-2"
      }
    }
  }
  all_mo_tests.dependsOn t

  t= task "mo_${mo}_test_3"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 3"
  ) {
    // Chunked output HTML, media all in the same relative locations

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-3"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-3"
    }

    doFirst {
      // N.B. These copy commands are a bit redundant because they
      // have to work for all of the input layouts
      copy {
        into "${buildDir}/actual/mo-${mo}-3"
        from "${projectDir}/src/test/resources/xml/mo-${mo}"
        include "**/*"
        exclude "**/*.xml"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-3"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    // no output
    args docbookXsltArgs 
    parameters([
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-3/"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-3"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_4"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 4"
  ) {
    // Chunked output HTML, media all in the same relative locations
    // but segregated by type

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    inputs.file "${projectDir}/src/test/resources/mo_1_test_4.xsl" // even for mo-2
    outputs.dir "${buildDir}/actual/mo-${mo}-4"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-4"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-4/image"
        from "${projectDir}/src/test/resources/xml/mo-${mo}"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/body/image"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/body"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/media/video"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "*.mp4"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/front/video"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/front"
        include "*.mp4"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/media/audio"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "*.mp3"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/media/image"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "*.png"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-4"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book.xml"
    stylesheet "${projectDir}/src/test/resources/mo_1_test_4.xsl" // even for mo-2
    // no output
    args docbookXsltArgs 
    parameters([
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-4/"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-4"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_5"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 5"
  ) {
    // Chunked output HTML, media all in a common directory

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-5"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-5"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-5/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-5/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/body"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-5/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/front"
        include "*.mp4"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-5/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-5"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    // no output
    args docbookXsltArgs 
    parameters([
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-5/",
      "mediaobject-output-base-uri": "media/",
      "mediaobject-output-paths": "false"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-5"
      }
    }
  }
  all_mo_tests.dependsOn t
}

// Test 3 is different because, although the media are relative to the
// source locations, they escape out above the "book" as might occur
// if you had several books with some common media.
["3"].each { mo ->
  Task t = task "mo_${mo}_test_1"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 1"
  ) {
    // Single output HTML file, media all in the same relative locations

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-1"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-1/book"
      mkdir "${buildDir}/actual/mo-${mo}-1/media"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-1"
        from "${projectDir}/src/test/resources/xml/mo-${mo}"
        include "**/*"
        exclude "**/*.xml"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-1/book"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    output "${buildDir}/actual/mo-${mo}-1/book/index.html"
    args docbookXsltArgs 

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-1"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_2"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 2"
  ) {
    // Single output HTML file, media all in a common directory

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-2"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-2/book"
    }

    doFirst {
      // N.B. These copy commands are a bit redundant because they
      // have to work for all of the input layouts
      copy {
        into "${buildDir}/actual/mo-${mo}-2/book/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/book/body"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-2/book/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-2/book"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    output "${buildDir}/actual/mo-${mo}-2/book/index.html"
    args docbookXsltArgs 
    parameters([
      "mediaobject-output-base-uri": "media/",
      "mediaobject-output-paths": "false"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-2"
      }
    }
  }
  all_mo_tests.dependsOn t

  t= task "mo_${mo}_test_3"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 3"
  ) {
    // Chunked output HTML, media all in the same relative locations

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-3"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-3/book"
      mkdir "${buildDir}/actual/mo-${mo}-3/media"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-3"
        from "${projectDir}/src/test/resources/xml/mo-${mo}"
        include "**/*"
        exclude "**/*.xml"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-3/book"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    // no output
    args docbookXsltArgs 
    parameters([
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-3/book/"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-3"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_4"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 4"
  ) {
    // Chunked output HTML, media all in the same relative locations
    // but segregated by type

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    inputs.file "${projectDir}/src/test/resources/mo_1_test_4.xsl" // even for mo-2
    outputs.dir "${buildDir}/actual/mo-${mo}-4"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-4/book"
      mkdir "${buildDir}/actual/mo-${mo}-4/media"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-4/book/body/image"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/book/body"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/media/image"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/media/audio"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "*.mp3"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/media/video"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "*.mp4"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/front/video"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/front"
        include "*.mp4"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-4/book"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${projectDir}/src/test/resources/mo_1_test_4.xsl" // even for mo-2
    // no output
    args docbookXsltArgs 
    parameters([
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-4/book/"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-4"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_5"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 5"
  ) {
    // Chunked output HTML, media all in a common directory

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-5"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-5"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-5/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/book/body"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-5/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "*.png"
        include "*.mp4"
        include "*.mp3"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-5"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    // no output
    args docbookXsltArgs 
    parameters([
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-5/",
      "mediaobject-output-base-uri": "media/",
      "mediaobject-output-paths": "false"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-5"
      }
    }
  }
  all_mo_tests.dependsOn t
}

// Test 4 stores the media in a separate hierarchy
["4"].each { mo ->
  Task t = task "mo_${mo}_test_1"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 1"
  ) {
    // Single output HTML file, media all in the same relative locations

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-1"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-1"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-1"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "**/*"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-1"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    output "${buildDir}/actual/mo-${mo}-1/index.html"
    args docbookXsltArgs 
    parameters([
      "mediaobject-input-base-uri": "../media/",
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-1"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_2"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 2"
  ) {
    // Single output HTML file, media all in a common directory

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-2"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-2"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-2/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-2"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    output "${buildDir}/actual/mo-${mo}-2/index.html"
    args docbookXsltArgs 
    parameters([
      "mediaobject-input-base-uri": "../media/",
      "mediaobject-output-base-uri": "media/",
      "mediaobject-output-paths": "true"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-2"
      }
    }
  }
  all_mo_tests.dependsOn t

  t= task "mo_${mo}_test_3"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 3"
  ) {
    // Chunked output HTML, media all in the same relative locations

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-3"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-3"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-3"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "**/*"
        exclude "**/*.xml"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-3"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    // no output
    args docbookXsltArgs 
    parameters([
      "mediaobject-input-base-uri": "../media/",
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-3/"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-3"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_4"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 4"
  ) {
    // Chunked output HTML, media all in the same relative locations
    // but segregated by type

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    inputs.file "${projectDir}/src/test/resources/mo_1_test_4.xsl" // even for mo-2
    outputs.dir "${buildDir}/actual/mo-${mo}-4"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-4"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-4/left/image"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media/left"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/right/image"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media/right"
        include "*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/video"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "*.mp4"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/audio"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "*.mp3"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-4"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${projectDir}/src/test/resources/mo_1_test_4.xsl" // even for mo-4
    // no output
    args docbookXsltArgs 
    parameters([
      "mediaobject-input-base-uri": "../media/",
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-4/"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-4"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_5"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 5"
  ) {
    // Chunked output HTML, media all in a common directory

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-5"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-5"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-5/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-5"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    // no output
    args docbookXsltArgs 
    parameters([
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-5/",
      "mediaobject-input-base-uri": "../media/",
      "mediaobject-output-base-uri": "media/",
      "mediaobject-output-paths": "true"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-5"
      }
    }
  }
  all_mo_tests.dependsOn t
}

// Test 5 stores the media grouped by type
["5"].each { mo ->
  Task t = task "mo_${mo}_test_1"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 1"
  ) {
    // Single output HTML file, media all in the same relative locations

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-1"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-1"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-1"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "**/*"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-1"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    output "${buildDir}/actual/mo-${mo}-1/index.html"
    args docbookXsltArgs 
    parameters([
      "mediaobject-input-base-uri": "../media/",
      "mediaobject-grouped-by-type": "true"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-1"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_2"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 2"
  ) {
    // Single output HTML file, media all in a common directory

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-2"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-2"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-2/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-2"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    output "${buildDir}/actual/mo-${mo}-2/index.html"
    args docbookXsltArgs 
    parameters([
      "mediaobject-input-base-uri": "../media/",
      "mediaobject-output-base-uri": "media/",
      "mediaobject-output-paths": "true",
      "mediaobject-grouped-by-type": "true"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-2"
      }
    }
  }
  all_mo_tests.dependsOn t

  t= task "mo_${mo}_test_3"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 3"
  ) {
    // Chunked output HTML, media all in the same relative locations

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-3"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-3"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-3"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
        include "**/*"
        exclude "**/*.xml"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-3"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    // no output
    args docbookXsltArgs 
    parameters([
      "mediaobject-input-base-uri": "../media/",
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-3/",
      "mediaobject-grouped-by-type": "true"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-3"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_4"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 4"
  ) {
    // Chunked output HTML, media all in the same relative locations
    // but segregated by type

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    inputs.file "${projectDir}/src/test/resources/mo_1_test_4.xsl" // even for mo-2
    outputs.dir "${buildDir}/actual/mo-${mo}-4"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-4"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-4/left/image"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media/left"
        include "**/*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/right/image"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media/right"
        include "**/*.png"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/video/mp4"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media/mp4"
      }
      copy {
        into "${buildDir}/actual/mo-${mo}-4/audio/mp3"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media/mp3"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-4"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${projectDir}/src/test/resources/mo_5_test_4.xsl"
    // no output
    args docbookXsltArgs 
    parameters([
      "mediaobject-input-base-uri": "../media/",
      "mediaobject-grouped-by-type": "true",
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-4/"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-4"
      }
    }
  }
  all_mo_tests.dependsOn t

  t = task "mo_${mo}_test_5"(
    type: SaxonXsltTask,
    dependsOn: ['makeXslt', 'copyResources'],
    group: "mediaobject-test",
    description: "Test source mo-${mo}, output version 5"
  ) {
    // Chunked output HTML, media all in a common directory

    inputs.dir "${projectDir}/src/test/resources/xml/mo-${mo}"
    inputs.dir "${buildDir}/xslt"
    outputs.dir "${buildDir}/actual/mo-${mo}-5"

    doFirst {
      mkdir "${buildDir}/actual/mo-${mo}-5"
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-5/media"
        from "${projectDir}/src/test/resources/xml/mo-${mo}/media"
      }
    }

    doFirst {
      copy {
        into "${buildDir}/actual/mo-${mo}-5"
        from "${buildDir}/actual"
        include "js/**"
        include "css/**"
      }
    }

    input "${projectDir}/src/test/resources/xml/mo-${mo}/book/book.xml"
    stylesheet "${buildDir}/xslt/docbook.xsl"
    // no output
    args docbookXsltArgs 
    parameters([
      "chunk": "index.html",
      "chunk-output-base-uri": "${buildDir}/actual/mo-${mo}-5/",
      "mediaobject-input-base-uri": "../media/",
      "mediaobject-output-base-uri": "media/",
      "mediaobject-output-paths": "true",
      "mediaobject-grouped-by-type": "true"
    ])

    doLast {
      exec {
        commandLine "python", "src/bin/linkcheck.py",
          "${buildDir}/actual/mo-${mo}-5"
      }
    }
  }
  all_mo_tests.dependsOn t
}

// ============================================================

task cleanXSpec() {
  doLast {
    fileTree(dir: buildDir, exclude: ["xspec-" + xspecVersion + ".zip",
                                      "xspec-" + xspecVersion + "/**",
                                      "docbook-" + docbookVersion + ".zip",
                                      "docbook-" + docbookVersion + "/**"])
      .each { artifact ->
        artifact.delete()
      }
  }
}
clean.dependsOn cleanXSpec

// ============================================================

task zipStagePygments() {
  if (pygmentize == "") {
    doLast {
      println("Without pygmentize, zip file resources will be incomplete.")
    }
  } else {
    doFirst {
      mkdir "${buildDir}/stage/zip/resources/css"
    }
    doLast {
      exec {
        commandLine "python3", "${projectDir}/tools/generate-pygments.py",
          "--version", xslTNGversion, "--title", xslTNGtitle,
          "--output", "${buildDir}/stage/zip/resources/css/pygments.css"
      }
    }
  }
}

task compileSass() {
  inputs.files fileTree("${projectDir}/src/main/scss")
  outputs.files fileTree("${buildDir}/css")

  doLast {
    exec {
      commandLine 'sass', '--style', 'expanded',
        '--no-source-map', '--no-charset',
        "${projectDir}/src/main/scss/docbook-screen.scss:${buildDir}/css/docbook.css",
        "${projectDir}/src/main/scss/docbook-paged.scss:${buildDir}/css/docbook-paged.css",
        "${projectDir}/src/main/scss/docbook-epub.scss:${buildDir}/css/docbook-epub.css",
        "${projectDir}/src/main/scss/toc.scss:${buildDir}/css/docbook-toc.css"
    }
  }

  doLast {
    exec {
      commandLine 'sass', '--style', 'compressed',
        '--no-source-map', '--no-charset',
        "${projectDir}/src/main/scss/docbook-screen.scss:${buildDir}/css/docbook.min.css",
        "${projectDir}/src/main/scss/docbook-paged.scss:${buildDir}/css/docbook-paged.min.css",
        "${projectDir}/src/main/scss/docbook-epub.scss:${buildDir}/css/docbook-epub.min.css",
        "${projectDir}/src/main/scss/toc.scss:${buildDir}/css/docbook-toc.min.css"
    }
  }

  doLast {
    ["docbook", "docbook-paged", "docbook-epub", "docbook-toc"].each { base ->
      [".css", ".min.css"].each { ext ->
        String fn = "${base}${ext}"
        File css = new File("${buildDir}/css/${fn}")
        def lines = []
        def reader = new BufferedReader(new FileReader(css))
        String line = null
        while ((line = reader.readLine()) != null) {
          lines.add(line)
        }
        reader.close()
        def writer = new PrintStream(css)
        writer.print("/")
        writer.print("* ${xslTNGtitle} version ${xslTNGversion}, https://xsltng.docbook.org *")
        if (ext == ".css") {
          writer.println("/");
        } else {
          writer.print("/");
        }
        lines.each { ln ->
          writer.println(ln);
        }
        writer.close();
      }
    }
  }
}

task zipStageResources(dependsOn: ["zipStagePygments", "compileSass"]) {
  doLast {
    copy {
      from "${buildDir}/css"
      into "${buildDir}/stage/zip/resources/css"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/main/web"
      include "css/*.png"
      into "${buildDir}/stage/zip/resources"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/main/web"
      include "css/**"
      include "js/**"
      exclude "css/*.png"
      into "${buildDir}/stage/zip/resources"
      filter { String line ->
        if (line.indexOf("@@") >= 0) {
          line = line
            .replace("@@TITLE@@", xslTNGtitle)
            .replace("@@VERSION@@", xslTNGversion)
        }
        line
      }
    }
  }
}

task zipStageSamples(dependsOn: ["zipStageResources"]) {
  doLast {
    copy {
      from "${buildDir}/stage/zip/resources"
      into "${buildDir}/stage/zip/samples"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/main/samples"
      into "${buildDir}/stage/zip/samples"
    }
  }
}

task zipStageXslt(type: Copy, dependsOn: ['makeXslt']) {
  from "${buildDir}/xslt"
  into "${buildDir}/stage/zip/xslt"
}

task zipStageMisc(type: Copy, dependsOn: ["zipStageSamples"]) {
  from "."
  into "${buildDir}/stage/zip"
  include "README.md"
  include "LICENSE"
}

task zipStageLib(dependsOn: ['jar', 'copyLib']) {
  doLast {
    copy {
      from "${buildDir}/libs"
      into "${buildDir}/stage/zip/libs"
      include "docbook-xslTNG-${xslTNGversion}.jar"
    }
  }
  doLast {
    copy {
      from "${buildDir}/libs/lib"
      into "${buildDir}/stage/zip/libs/lib"
    }
  }
}

task zipStageBin(type: Copy, dependsOn: ['copyBin']) {
  from "${buildDir}/bin"
  into "${buildDir}/stage/zip/bin"
}

task zipStageDocker(type: Copy, dependsOn: ['copyDocker']) {
  from "${buildDir}/docker"
  into "${buildDir}/stage/zip/docker"
}

task zipStageCatalog(
  type: SaxonXsltTask,
  dependsOn: ['makeUriList', 'zipStageXslt', "stageJar", "processResources"]) {
  input makeUriList.outputs.files.getSingleFile()
  stylesheet "${projectDir}/src/main/resources/org/docbook/xsltng/etc/make-catalog.xsl"
  output "${buildDir}/stage/zip/xslt/catalog.xml"
  parameters(
    'version': xslTNGversion
  )
}

task zipStage(type: Copy, dependsOn: ['zipStageBin', 'zipStageDocker', 'zipStageLib',
                                      'zipStageMisc', 'zipStageCatalog']) {
  // nop
}

task releaseArtifacts(type: Copy, dependsOn: ['zipStage']) {
  from "${buildDir}/stage/zip"
  into "${buildDir}/release"
  exclude "bin/**"
  exclude "libs/**"
  exclude "samples/**"
  exclude "docker/**"
}

task zipDist(type: Zip, dependsOn: ['zipStage']) {
  from("${buildDir}/stage/zip")
  into "${xslTNGbaseName}-${xslTNGversion}"
  archiveFileName = "${xslTNGbaseName}-${xslTNGversion}.zip"
}

task relnotes(
  type: Exec,
  description: "Checks for release notes"
) {
  ignoreExitValue true
  def stream = new ByteArrayOutputStream();
  commandLine "grep", "revnumber.${xslTNGversion}", "${projectDir}/src/guide/xml/guide.xml"
  standardOutput = stream
  doLast {
    String notes = stream.toString('utf-8')
    if (notes.trim() == "") {
      println("************************************************************")
      println("There are no release notes for xslTNG version ${xslTNGversion}")
      println("************************************************************")
    }
  }
}

// ============================================================

task dist(
  dependsOn: ['requirePassingTests', 'releaseArtifacts', 'zipDist', 'website', 'relnotes']
) {
  doLast {
    println("Built dist for ${xslTNGtitle} version ${xslTNGversion}")
  }
}

// ============================================================

task explorer(type: SaxonXsltTask,
              dependsOn: ['makeXslt',
                          'setupXsltExplorer', 'explorerResources']) {
  inputs.files fileTree(dir: "${buildDir}/xslt")
  outputs.file("${buildDir}/docbook-xslTNG.xml")

  input "${buildDir}/xslt/docbook.xsl"
  stylesheet "${buildDir}/xsltexplorer-${xsltExplorerVersion}/xslt/explorer.xsl"
  output "${buildDir}/explorer/index.html"
  args docbookXsltArgs 
  arg '-l:on'
  parameters(
    'debug-analyze': "${buildDir}/docbook-xslTNG.xml"
  )
}

task explorerResources(type: Copy, dependsOn: ['setupXsltExplorer']) {
  into "${buildDir}/explorer"
  from "${buildDir}/xsltexplorer-${xsltExplorerVersion}"
  include "css/**"
  include "js/**"
}

task guideResources(dependsOn: ['guideDocBookResources','guideCustomResources']) {
  // nop
}

task guideDocBookResources(type: Copy, dependsOn: ['copyResources', 'explorer']) {
  from "${buildDir}/actual"
  include "css/**"
  include "js/**"
  exclude "css/print.css"
  into "${buildDir}/guide/"
}

task guideCustomResources(type: Copy) {
  from "${projectDir}/src/guide/resources"
  include "css/**"
  include "js/**"
  include "media/**"
  include "*.html"
  into "${buildDir}/guide/"
}

task prepareToXIncludeGuideCopy(type: Copy) {
  from "${projectDir}/src/guide/xml"
  into "${buildDir}/tmp/guide"
  exclude "ref-params.xml"
}

task prepareToXIncludeGuideTransform(type: SaxonXsltTask) {
  input "${projectDir}/src/guide/xml/ref-params.xml"
  stylesheet "${projectDir}/tools/generate-ref-params.xsl"
  output "${buildDir}/tmp/guide/ref-params.xml"
}

task xincludeGuide(type: SaxonXsltTask,
                   dependsOn: ['guideResources', 'prepareToXIncludeGuideCopy',
                               'prepareToXIncludeGuideTransform']) {
  inputs.files fileTree(dir: "${buildDir}/tmp/guide")
  inputs.file "${projectDir}/tools/xinclude.xsl"

  input "${buildDir}/tmp/guide/guide.xml"
  stylesheet "${projectDir}/tools/xinclude.xsl"
  output "${buildDir}/guide.xml"
  args docbookXsltArgs 
}

task copyGuide(type: SaxonXsltTask, dependsOn: ['xincludeGuide']) {
  input "${buildDir}/guide.xml"
  stylesheet "${projectDir}/tools/guide-pis.xsl"
  output "${buildDir}/guide/guide.xml"
}

task validateGuide(type: RelaxNGValidateTask, dependsOn: ['copyGuide']) {
  input "${buildDir}/guide/guide.xml"
  schema "${projectDir}/src/test/resources/docbook.rng"
  output "${buildDir}/guide/validated.xml"
}

task guide(
  type: SaxonXsltTask,
  dependsOn: ['makeXslt', 'validateGuide', 'explorer']
) {
  inputs.files fileTree(dir: "${buildDir}/xslt")
  inputs.files fileTree(dir: "${projectDir}/src/guide/xml")
  inputs.files fileTree(dir: "${projectDir}/src/guide/xsl")
  inputs.file("${buildDir}/docbook-xslTNG.xml")
  outputs.file("${buildDir}/guide/index.html")

  input "${buildDir}/guide/guide.xml"
  stylesheet "${projectDir}/src/guide/xsl/guide.xsl"
  output "${buildDir}/guide/irrelevant-and-deleted-file.html"
  args docbookXsltArgs 
  parameters(
    'explorer.xml': "${buildDir}/docbook-xslTNG.xml",
    'bookVersion': guideVersion,
    'xslTNGversion': xslTNGversion,
    'profile-outputformat': 'online',
    'chunk': 'index.html',
    'chunk-output-base-uri': "${projectDir}/build/guide/"
  )

  doLast {
    delete "${buildDir}/guide/irrelevant-and-deleted-file.html"
  }
}

task guide_fonts(
  type: Copy
) {
  from "${projectDir}/src/guide/resources/fonts"
  into "${buildDir}/guide/css/fonts"
  include "**/*.ttf"
  eachFile {
    path = name
  }
  includeEmptyDirs = false
}

task "guide.pdf.html"(
  type: SaxonXsltTask,
  dependsOn: ['makeXslt', 'validateGuide', 'explorer', 'guide_fonts']
) {
  inputs.files fileTree(dir: "${buildDir}/xslt")
  inputs.file "${buildDir}/docbook-xslTNG.xml"
  inputs.files fileTree(dir: "${projectDir}/src/guide/xsl")

  input "${buildDir}/guide/guide.xml"
  stylesheet "${projectDir}/src/guide/xsl/print.xsl"
  output "${buildDir}/guide/guide.pdf.html"
  args docbookXsltArgs 
  parameters(
    'explorer.xml': "${buildDir}/docbook-xslTNG.xml",
    'bookVersion': guideVersion,
    'xslTNGversion': xslTNGversion,
    'profile-outputformat': 'print',
    'page-style': 'book',
    'resource-base-uri': ''
  )
}

if (pdftool == "prince") {
  task "guide.pdf"(type: Exec, dependsOn: ["guide.pdf.html"]) {
    inputs.file("${buildDir}/guide/guide.pdf.html")
    inputs.files fileTree(dir: "${buildDir}/guide/css")
    outputs.file("${buildDir}/guide/guide.pdf")
    commandLine "${prince}",
      "${buildDir}/guide/guide.pdf.html",
      "-o", "${buildDir}/guide/guide.pdf"
  }
} else {
  task "guide.pdf"(type: Exec, dependsOn: ["guide.pdf.html"]) {
    inputs.file("${buildDir}/guide/guide.pdf.html")
    inputs.files fileTree(dir: "${buildDir}/guide/css")
    outputs.file("${buildDir}/guide/guide.pdf")
    commandLine "${antennahouse}",
      "-d", "${buildDir}/guide/guide.pdf.html",
      "-o", "${buildDir}/guide/guide.pdf"
  }
}

task "guide.olinkdb"(type: SaxonXsltTask, dependsOn: ['guide']) {
  inputs.files fileTree(dir: "${buildDir}/xslt")
  inputs.files fileTree(dir: "${projectDir}/src/guide/xsl")
  inputs.file("${buildDir}/docbook-xslTNG.xml")

  input "${buildDir}/guide/guide.xml"
  stylesheet "${buildDir}/xslt/olinkdb.xsl"
  output "${buildDir}/actual/guide.olinkdb"
  args docbookXsltArgs 
  parameters(
    'explorer.xml': "${buildDir}/docbook-xslTNG.xml",
    'bookVersion': guideVersion,
    'xslTNGversion': xslTNGversion,
    'profile-outputformat': 'online',
    'chunk': 'index.html',
    'chunk-output-base-uri': "https://xsltng.docbook.org/guide/",
    'olink-targetdoc': 'Guide'
  )
}

// ============================================================

task website(type: Copy, dependsOn: ['webGuide', 'webReport', 'webExplorer',
                                     'webHtml', 'webResources', 'epubGuide']) {
  into "${buildDir}/website/epub"
  from "${buildDir}/epub"
  include "*.epub"
  rename { filename ->
    "DocBook-${filename}"
  }
}

task webGuide(
  dependsOn: ['guide', 'guide.olinkdb']
) {
  inputs.dir "${buildDir}/guide"
  outputs.dir "${buildDir}/website/guide/${guideVersion}"
  outputs.file "${buildDir}/website/guide/index.html"

  doLast {
    copy {
      from "${buildDir}/guide"
      exclude "guide.xml"
      exclude "validated.xml"
      into "${buildDir}/website/guide/${guideVersion}"
    }
  }

  doLast {
    if (!guidePrerelease) {
      File html = new File("${buildDir}/website/guide/index.html")
      def writer = new PrintStream(html)
      writer.println('<!DOCTYPE html>')
      writer.println('<html>')
      writer.println('<head>')
      writer.println("<meta http-equiv='refresh' content=\"0; url='${guideVersion}/'\" />")
      writer.println('</head>')
      writer.println('<body>')
      writer.println('<p>The current guide is ')
      writer.println("<a href='${guideVersion}/'>version ${guideVersion}</a>.</p>")
      writer.println('</body>')
      writer.println('</html>')
      writer.close()
    }
  }
}

task webExplorer(type: Copy, dependsOn: ['explorer']) {
  from "${buildDir}/explorer"
  into "${buildDir}/website/explorer"
}

task webReport(type: Copy, dependsOn: ['report']) {
  from "${buildDir}/report"
  into "${buildDir}/website/report"
}

task webResources(type: Copy, dependsOn: ['report']) {
  from "${projectDir}/src/website/resources/"
  into "${buildDir}/website"
  exclude "images/**"
  exclude "olinkdb/**"
}

task webHtml(type: Copy, dependsOn: ['report', 'webHomepage']) {
  from "${projectDir}/src/website/html"
  into "${buildDir}/website"
  exclude "homepage.html"
}

def buildTag = System.getenv()["CIRCLE_TAG"]
if (buildTag == null) {
  buildTag = ""
}
task webHomepage(type: SaxonXsltTask, dependsOn: ['testSummary']) {
  input "${projectDir}/src/website/html/homepage.html"
  stylesheet "${projectDir}/tools/homepage.xsl"
  output "${buildDir}/website/index.html"
  parameters(
    "build-tag": buildTag
  )
}

// ============================================================

task copyLib() {
  String path = ""
  configurations.projectImplementationClasspath.each { file ->
    path += " lib/" + file.name
    if (file.name.endsWith(".jar")) {
      doLast {
        copy {
          from file
          into "${buildDir}/libs/lib"
        }
      }
    }
  }
  project.ext.runtimeClasspath = path.trim()
}
jar.dependsOn copyLib

task makeVersionProperties() {
  outputs.file "${buildDir}/resources/main/org/docbook/xsltng/etc/version.properties"

  doFirst {
    mkdir("${buildDir}/resources/main/org/docbook/xsltng/etc")
  }
  doLast {
    new File("${buildDir}/resources/main/org/docbook/xsltng/etc/version.properties").withWriter("utf-8") { writer ->
      writer.writeLine("version=${xslTNGversion}")
    }
  }
}

task jarStageCatalog(type: SaxonXsltTask, dependsOn: ['makeUriList']) {
  input makeUriList.outputs.files.getSingleFile()
  stylesheet "${projectDir}/src/main/resources/org/docbook/xsltng/etc/make-catalog.xsl"
  output "${buildDir}/resources/main/org/docbook/xsltng/catalog.xml"
  parameters(
    'version': xslTNGversion,
    'jarloc': 'classpath:org/docbook/xsltng/'
  )
  doLast {
    copy {
      into "${buildDir}/resources/main/org/xmlresolver"
      from ("${buildDir}/resources/main/org/docbook/xsltng") {
        include "catalog.xml"
      }
    }
  }
}

task stageJar(
  dependsOn: ["makeXslt", "makeVersionProperties", "makeUriList", "jarStageCatalog",
              "zipStagePygments"]
) {
  inputs.files fileTree(dir: "${projectDir}/buildSrc/build/classes/java/main")
  inputs.files fileTree(dir: "${projectDir}/buildSrc/build/classes/java/groovy")
  inputs.files fileTree(dir: "${buildDir}/stage/zip/resources")
  inputs.files fileTree(dir: "${buildDir}/xslt")
  outputs.files fileTree(dir: "${buildDir}/resources/main")

  doLast {
    copy {
      into "${buildDir}/resources/main"
      from "${projectDir}/buildSrc/build/classes/java/main"
    }
    copy {
      into "${buildDir}/resources/main/org/docbook/xsltng/resources"
      from "${buildDir}/stage/zip/resources"
    }
    // Not ${buildDir}/classes/java/main because the jar task
    // picks those up automatically and we don't want duplicates
    copy {
      into "${buildDir}/resources/main/org/docbook/xsltng/xslt"
      from "${buildDir}/xslt"
    }
  }
}
processResources.dependsOn stageJar

jar {
  archiveBaseName = "docbook-xslTNG-${xslTNGversion}"
  manifest {
    attributes "Built-By": "Norman Walsh"
    attributes "Implementation-Vendor": "Norman Walsh"
    attributes "Implementation-Title": "DocBook xslTNG Stylesheets"
    attributes "Implementation-Version": xslTNGversion
    attributes "Main-Class": "org.docbook.xsltng.Main"
    attributes "Bundle-SymbolicName": "org.docbook.xsltng"
    attributes "Bundle-RequiredExecutionEnvironment": "J2SE-1.7"
    attributes "Export-Package": "*: etc"
    attributes "Import-Package": "net.sf.saxon.*;version=${saxonVersion}:\
  javax.xml.*:\
  *;resolution:=optional"
    attributes "DynamicImport-Package": "*"
    // This is a bit of a hack; special case the three most likely
    // commercial jar files for printing with CSS or FO.
    attributes "Class-Path": project.ext.runtimeClasspath \
              + " lib/XfoJavaCtl.jar lib/xep.jar lib/prince.jar"
  }
  from "${buildDir}/resources/main"
}

task javadocJar(type: Jar, dependsOn: javadoc) {
  classifier = 'javadoc'
  from javadoc.destinationDir
}

task sourcesJar(type: Jar) {
  classifier = 'sources'
  from sourceSets.main.allSource
}

// ============================================================

signing {
  sign publishing.publications
}

publishing {
  publications {
    mavenJava(MavenPublication) {
      pom {
        name = xslTNGtitle
        packaging = 'jar'
        description = 'DocBook xslTNG Stylesheets'
        url = 'https://github.com/docbook/xslTNG'

        scm {
          url = 'scm:git@github.com:docbook/xslTNG.git'
          connection = 'scm:git@github.com:docbook/xslTNG.git'
          developerConnection = 'scm:git@github.com:docbook/xslTNG.git'
        }

        licenses {
          license {
            name = 'Apache License version 2.0'
            url = 'https://www.apache.org/licenses/LICENSE-2.0'
            distribution = 'repo'
          }
        }

        developers {
          developer {
            id = 'ndw'
            name = 'Norman Walsh'
          }
        }
      }

      groupId = "org.docbook"
      artifactId = "docbook-xslTNG"
      version = xslTNGversion
      from components.java
      artifact javadocJar
      artifact sourcesJar
    }
  }

  repositories {
    maven {
      url = xslTNGversion.contains("SNAPSHOT") ?
        "https://oss.sonatype.org/content/repositories/snapshots/" :
        "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
      credentials {
        username = findProperty("sonatypeUsername") ?: ""
        password = findProperty("sonatypePassword") ?: ""
      }
    }
  }
}

// ============================================================

task epubGuideResources(
  dependsOn: ["copyResources"]
) {
  inputs.files fileTree(dir: "${buildDir}/actual/css")
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/fonts")
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/css")
  outputs.files fileTree(dir: "${buildDir}/epub/OPS/css")

  doLast {
    copy {
      from "${buildDir}/actual/css"
      into "${buildDir}/epub/OPS/css"
      include "docbook-epub.css"
      include "draft*.svg"
      include "draft*.png"
      include "pygments.css"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/guide/resources/css"
      into "${buildDir}/epub/OPS/css"
      include "guide-epub.css"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/guide/resources/fonts"
      into "${buildDir}/epub/OPS/css/fonts"
      include "**/*.ttf"
      exclude "**/*ExtraBold*"
      exclude "**/*SemiBold*"
      exclude "**/*Light*"
      exclude "**/*Thin*"
      eachFile {
        path = name
      }
      includeEmptyDirs = false
    }
  }
}

task epubGuideMedia(
  dependsOn: ["epubGuideResources"]
) {
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/css")
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/media")
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/media")
  outputs.files fileTree(dir: "${buildDir}/epub/OPS/css") 
  outputs.files fileTree(dir: "${buildDir}/epub/OPS/media")
  outputs.file "${buildDir}/epub/manifest-extra.xml"

  doLast {
    copy {
      into "${buildDir}/epub/OPS/css"
      from "${projectDir}/src/guide/resources/css"
      exclude "guide-paged.css"
    }
  }

  doLast {
    copy {
      into "${buildDir}/epub/OPS/media"
      from "${projectDir}/src/guide/resources/media"
    }
  }

  doLast {
    def m = new PrintStream(new File("${buildDir}/epub/manifest-extra.xml"))
    m.println("<manifest xmlns='http://www.idpf.org/2007/opf'>")
    fileTree(dir: "${buildDir}/epub/OPS",
             includes: ["media/**", "css/**"]).each { rsrc ->
      String href = rsrc.toString()
      int pos = href.indexOf("/OPS/")
      href = href.substring(pos+5)
      String id = href.replaceAll("/", "_")

      pos = href.lastIndexOf(".")
      String ext = href.substring(pos+1)
      String mediaType = "application/octet-stream"

      if (epubMediaTypes[ext] != null) {
        mediaType = epubMediaTypes[ext]
      } else {
        println("Warning: Unknown media type: ${href}")
      }

      m.print("<item id='id_${id}' href='${href}' media-type='${mediaType}'")
      if (mediaType == 'image/svg') {
        m.print(" fallback='id_${id.replaceAll('.svg$', '.png')}'")
      }
      if (mediaType.startsWith('image/') && href.startsWith('media/cover.')) {
        m.print(" properties='cover-image'")
      }
      m.println("/>")
    }
    m.println("</manifest>")
    m.close()
  }
}

task epubGuideFormat(
  type: SaxonXsltTask,
  dependsOn: ['makeXslt', 'validateGuide', 'explorer', 'epubGuideMedia']
) {
  inputs.files fileTree(dir: "${buildDir}/xslt")
  inputs.files fileTree(dir: "${projectDir}/src/guide/xsl")
  inputs.file "${buildDir}/guide/guide.xml"
  outputs.files fileTree(dir: "${buildDir}/epub")

  input "${buildDir}/guide/guide.xml"
  stylesheet "${projectDir}/src/guide/xsl/epub.xsl"
  output "${buildDir}/epub/mimetype"
  args docbookXsltArgs 
  parameters(
    'profile-outputformat': 'online',
    'chunk': 'titlepage.xhtml',
    'chunk-output-base-uri': "${buildDir}/epub/",
    'explorer.xml': "${buildDir}/docbook-xslTNG.xml",
    'bookVersion': guideVersion,
    'xslTNGversion': xslTNGversion,
    'pub-id': "xslTNG-guide-${guideVersion}",
    'manifest-extra': "${buildDir}/epub/manifest-extra.xml"
  )
}

task epubGuide(
  dependsOn: ["epubGuideResources", "epubGuideMedia", "epubGuideFormat"]
) {
  inputs.files fileTree(dir: "${buildDir}/epub", exclude: "*.epub")
  outputs.file "${buildDir}/epub/xslTNG-${guideVersion}.epub"

  def epub_file = epubGuide.outputs.getFiles().getSingleFile().toString()

  doLast {
    delete epub_file
  }

  doLast {
    exec {
      workingDir "${buildDir}/epub"
      commandLine "zip", "-q", "-X0", epub_file, "mimetype"
    }
  }

  doLast {
    exec {
      workingDir "${buildDir}/epub"
      commandLine "zip", "-q", "-rp", epub_file, "META-INF", "OPS"
    }
  }

  doLast {
    exec {
      workingDir "${buildDir}/epub"
      commandLine "epubcheck", epub_file
    }
  }
}

// ============================================================

task dbtransform(type: SaxonXsltTask, dependsOn: ['makeXslt']) {
  outputs.upToDateWhen { false }
  doFirst {
    if (dbsource = '') {
      throw new GradleException("You must specify -Pdbsource=...")
    }
    if (dboutput = '') {
      throw new GradleException("You must specify -Pdboutput=...")
    }
  }

  def ssparams = [:]
  doFirst {
    if (dbparams.trim() != "") {
      dbparams.split(/\s+/).each { param ->
        def pos = param.indexOf('=')
        if (pos <= 0) {
          throw new GradleException("Malformed parameter: ${param}")
        } else {
          def name = param.substring(0, pos).replace(/%20/, ' ')
          def value = param.substring(pos+1).replace(/%20/, ' ')
          ssparams[name] = value
        }
      }
    }
  }

  def xslt = "${buildDir}/xslt/docbook.xsl"
  if (dbstyle != '') {
    xslt = dbstyle
  }

  input "${dbsource}"
  stylesheet "${xslt}"
  args docbookXsltArgs 

  if (dboutput != '-') {
    output "${dboutput}"
  }

  parameters(ssparams)
}

task helloWorld() {
  doLast {
    println('Hello, world')

/*
    configurations.validateRuntime.each { path ->
      println("CP: ${path}")
    }
    configurations.projectRuntimeClasspath.each { path ->
      println("R: ${path}")
    }
    configurations.projectImplementationClasspath.each { path ->
      println("I: ${path}")
    }
    configurations.compileClasspath.each { cp ->
      println("CCP: ${cp}")
    }
    println("${EXCP}")
*/
  }
}
