buildscript {
  repositories {
    mavenLocal()
    mavenCentral()
    maven { url "https://dev.saxonica.com/maven" }
  }

  apply from: 'properties.gradle'

  configurations.all {
    resolutionStrategy {
      exclude group: 'xml-apis', module: 'xml-apis'
      exclude group: 'xerces', module: 'xercesImpl'
      force "${saxonGroup}:${saxonEdition}:${saxonVersion}",
        "org.xmlresolver:xmlresolver:${xmlresolverVersion}"
    }
  }

  dependencies {
    classpath group: saxonGroup, name: saxonEdition, version: saxonVersion
    classpath group: 'com.drewnoakes', name: 'metadata-extractor', version: metadataExtractorVersion
    classpath group: 'com.nwalsh', name: 'sinclude', version: sincludeVersion
    classpath group: 'org.xmlresolver', name: 'xmlresolver', version: xmlresolverVersion
    classpath group: 'org.docbook', name: 'schemas-docbook', version: docbookVersion
    classpath group: 'org.docbook', name: 'schemas-publishers', version: docbookVersion
  }
}

plugins {
  id "java"
  id "groovy"
  id "maven-publish"
  id "signing"
  // The com.nwalsh.gradle.saxon.saxon-gradle plugin is loaded in buildSrc
  // The com.nwalsh.gradle.relaxng.validate plugin is loaded in buildSrc
  // The com.nwalsh.gradle.relaxng.translate plugin is loaded in buildSrc
  id "de.undercouch.download" version "4.0.4"
}

java {
  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8
}

sourceSets {
  main {
    java {
      srcDirs = ['src/main/java']
    }
  }
}

import static groovy.io.FileType.DIRECTORIES
import org.gradle.internal.os.OperatingSystem;

import com.nwalsh.gradle.saxon.SaxonXsltTask
import com.nwalsh.gradle.relaxng.validate.RelaxNGValidateTask
import com.nwalsh.gradle.relaxng.translate.RelaxNGTranslateTask

import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.security.MessageDigest
import java.time.Instant
import java.time.format.DateTimeFormatter

import java.util.zip.ZipOutputStream
import java.util.zip.ZipEntry

import de.undercouch.gradle.tasks.download.Download

import org.docbook.xsltng.gradle.TestUtils
import org.docbook.xsltng.gradle.TestGenerator

repositories {
  mavenLocal()
  mavenCentral()
  maven { url "https://dev.saxonica.com/maven" }
}

apply from: 'properties.gradle'

configurations.all {
  resolutionStrategy {
    exclude group: 'xml-apis', module: 'xml-apis'
    exclude group: 'xerces', module: 'xercesImpl'
    force "${saxonGroup}:${saxonEdition}:${saxonVersion}",
      "org.xmlresolver:xmlresolver:${xmlresolverVersion}"
  }
}

configurations {
  validateRuntime.extendsFrom(testImplementation)
  projectImplementationClasspath.extendsFrom(implementation)
  projectRuntimeClasspath.extendsFrom(runtimeOnly)
}

ext {
  requireCompileSuccess = !"false".equals(project.property('requireCompileSuccess'))
  epubMediaTypes = [
    "css": "text/css",
    "ttf": "font/ttf",
    "woff": "font/woff",
    "jpg": "image/jpeg",
    "jpeg": "image/jpeg",
    "png": "image/png",
    "gif": "image/gif",
    "svg": "image/svg"
  ]
  computedGitRef = null
  extraParams = [:]
  fProjectDir = projectDir.toString()
  uProjectDir = TestUtils.fixWindowsPath(fProjectDir)
  fBuildDir = buildDir.toString()
  uBuildDir = TestUtils.fixWindowsPath(fBuildDir)
  XSPEC = OperatingSystem.current().isWindows() ? 'xspec.bat' : 'xspec.sh'
}

project.properties.keySet().each { key ->
  if (key.startsWith("ep_")) {
    println("SETTING ${key.substring(3)}")
    extraParams[key.substring(3)] = project.properties.get(key).trim()
  }
}

// Set saxonLicenseDir in gradle.properties, or from the
// command line if you have a license in some other place.
if (!hasProperty("saxonLicenseDir")) {
  if (System.getenv("SAXON_LICENSE_DIR") != null) {
    ext.saxonLicenseDir=System.getenv('SAXON_LICENSE_DIR')
  } else {
    ext.saxonLicenseDir=System.getenv('HOME') + "/java"
  }
}

dependencies {
  implementation (
    [group: saxonGroup, name: saxonEdition, version: saxonVersion],
    [group: 'com.drewnoakes', name: 'metadata-extractor', version: metadataExtractorVersion],
    [group: 'org.relaxng', name: 'jing', version: jingVersion ],
    [group: 'org.relaxng', name: 'trang', version: jingVersion ],
    [group: 'org.xmlresolver', name: 'xmlresolver', version: xmlresolverVersion],
    [group: 'com.nwalsh', name: 'sinclude', version: sincludeVersion ],
    [group: 'org.w3c', name: 'epubcheck', version: '5.0.1'],
    files("${projectDir}/buildSrc/build/classes/java/main"),
    files(saxonLicenseDir)
  )
  testImplementation (
    [group: 'junit', name: 'junit', version: '4.13'],
    [group: 'org.docbook', name: 'schemas-docbook', version: docbookVersion],
    [group: 'org.docbook', name: 'schemas-publishers', version: docbookVersion]
  )
}

defaultTasks 'report'

def docbookXsltArgs = ['-init:org.docbook.xsltng.extensions.Register']

// If this is running on the CI infrastructure and it's not
// a tagged build, add -SNAPSHOT to the version.
if (System.getenv()["CIWORKFLOW"] == "yes"
    && (System.getenv()["CI_TAG"] == null || System.getenv()["CI_TAG"] == "")
    && !xslTNGversion.contains('SNAPSHOT')) {
  xslTNGversion = xslTNGversion + "-SNAPSHOT"
}

// I'm not sure I want to generate *all* the PDF files.
// This is a kind of random list...
def pdfTests = ['article.003', 'book.001', 'book.003',
                'calloutlist.001', 'changebars.001', 'mediaobject.001'];

class SummarizeTestResults extends DefaultTask {
  @Input
  String[] resultFiles = []

  @TaskAction
  def docheck() {
    resultFiles.each { driver ->
      def base = driver.substring(0, driver.length() - 6)
      println(base)
    }
  }
}

class CheckTextFile extends DefaultTask {
  @Input
  String checkFile = null

  @TaskAction
  def docheck() {
    def pass = true
    new File(checkFile).eachLine { line ->
      if (line.endsWith("failed") && !line.equals("0 failed")) {
        pass = false
      }
      println(line)
    }
    if (!pass) {
      if ((project.findProperty('requireTestSuccess') ?: "true") != "false") {
        throw new GradleException("Failing tests!")
      }
      println("WARNING: Some tests failed")
    }
  }
}

def gitRef() {
  // Depending on the state of your repo, this can be time consuming,
  // so don't bother unless you're demanding complete success...
  if (computedGitRef != null) {
    return computedGitRef
  }

  def ref = null;
  if (requireCompileSuccess) {
    def gitRepo = new File(".git")
    if (gitRepo.exists() && gitRepo.isDirectory()) {
      def command = ['git', 'rev-parse', '--short', '--verify', 'HEAD']
      ProcessBuilder pb = new ProcessBuilder().command(command)
      pb.directory(projectDir)
      Process proc = pb.start()

      def reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
      String line = null
      while ((line = reader.readLine()) != null) {
        if (ref == null) {
          ref = line
        }
      }

      reader = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
      while ((line = reader.readLine()) != null) {
        println(line)
      }

      proc.waitFor()
    }
  } else {
    ref = "SNAPSHOT"
  }

  computedGitRef = ref

  if (ref == null) {
    ref = "Unknown"
    println("This doesn't appear to be a git clone; using VERSION-ID: ${ref}")
  } else {
    println("Using git ref as VERSION-ID: ${ref}")
  }

  return ref
}

def pygmentize = findPygmentize()
def findPygmentize() {
  def path = System.getenv()["PATH"] == null ? System.getenv()["Path"] : System.getenv()["PATH"]
  def script = null
  def pathsep = System.getProperty("path.separator")
  def pygmentize = OperatingSystem.current().isWindows() ? 'pygmentize.exe' : 'pygmentize'

  path.split(pathsep).each { segment ->
    if (script == null) {
      def testfile = new File("${segment}/${pygmentize}")
      if (testfile.exists() && testfile.canExecute()) {
        script = testfile.toString()
      }

      if (segment.endsWith("/.pyenv/shims")) {
        // Ok, we found pyenv, now can we find pygmentize?
        def pyenv = new File("${segment.substring(0, segment.length() - 6)}/versions")
        def versions = []
        pyenv.traverse(type: DIRECTORIES, maxDepth: 0) { dir ->
          testfile = new File("${dir}/bin/${pygmentize}")
          if (testfile.exists() && testfile.canExecute()) {
            script = testfile.toString()
          }
        }
      }
    }
  }

  if (script == null) {
    println("Could not find pygmentize")
    script = "" // nevermind
  } else {
    println("Using Pygments from ${script}")
  }

  return script
}

// This is all a complete hack that I worked out by trial and error
def EXCP="${projectDir}/build/classes/java/main"
configurations.validateRuntime.each { it ->
  EXCP += System.getProperty("path.separator") + it
}

// Set system properties
System.setProperty("org.docbook.xsltng.extensions.verbose", verbose)
System.setProperty("org.docbook.extensions.pygmentize", pygmentize)

println("Using Java version ${System.getProperty('java.version')}")

task configureEnvironment() {
  def envVars = [:]
  envVars['TEST_DIR'] = buildDir
  envVars['SAXON_CP'] = EXCP
  envVars['PYGMENTIZE'] = pygmentize
  envVars['VERBOSE'] = verbose
  tasks.withType(Exec) {
    environment << envVars
  }
}

task setupXSpec(type: Download) {
  src "https://github.com/xspec/xspec/archive/v${xspecVersion}.zip"
  dest file("${buildDir}/xspec-${xspecVersion}.zip")
  doFirst {
    mkdir(buildDir)
  }
  doLast {
    copy {
      from zipTree("${buildDir}/xspec-${xspecVersion}.zip")
      into buildDir
    }
  }
  doLast {
    copy {
      from "${projectDir}/src/test/resources/xspec"
      into "${buildDir}/xspec-${xspecVersion}/src/common"
      include "uri-utils.xsl"
    }
  }
  doLast {
    copy {
      from "${projectDir}/src/test/resources/xspec"
      into "${buildDir}/xspec-${xspecVersion}/bin"
      include "xspec.sh"
      include "xspec.bat"
    }
  }
  onlyIf { !file("${buildDir}/xspec-${xspecVersion}/README.md").exists() }
}

task setupXsltExplorer(type: Download) {
  outputs.file "${buildDir}/xsltexplorer-${xsltExplorerVersion}/xslt/explorer.xsl"

  src "https://github.com/ndw/xsltexplorer/releases/download/${xsltExplorerVersion}/xsltexplorer-${xsltExplorerVersion}.zip"
  dest file("${buildDir}/xsltexplorer-${xsltExplorerVersion}.zip")
  doFirst {
    mkdir(buildDir)
  }
  doLast {
    copy {
      from zipTree("${buildDir}/xsltexplorer-${xsltExplorerVersion}.zip")
      into buildDir
    }
  }

  onlyIf { !file("${buildDir}/xsltexplorer-${xsltExplorerVersion}/README.org").exists() }
}

task copyResources(type: Copy,
                   dependsOn: ['copyTestMedia', 'zipStageResources',
                               'zipStageMisc']) {
  from "${buildDir}/stage/zip/resources"
  into "${buildDir}/actual"
  exclude "scss/**"
}

def pkglist = ["net.sf.saxon:Saxon-HE:${saxonVersion}",
               "com.drewnoakes:metadata-extractor:${metadataExtractorVersion}",
               "org.relaxng:jing:${jingVersion}",
               "org.xmlresolver:xmlresolver:${xmlresolverVersion}",
               "com.nwalsh:sinclude:${sincludeVersion}"]

task copyBin(type: Copy) {
  def packages = ""
  pkglist.each { pkg ->
    if (packages != "") {
      packages += ",\n                          "
    }
    packages = packages + "\"${pkg}\""
  }

  from "${projectDir}/src/bin"
  into "${buildDir}/bin"
  exclude '.mypy_cache/**'
  rename("docbook.py", "docbook")
  filter { String line ->
    if (line.indexOf("@@") >= 0) {
      line = line
        .replace("\"@@PACKAGE_LIST@@\"", packages)
        .replace("@@VERSION@@", xslTNGversion)
    }
    line
  }
}

task copyDocker(type: Copy) {
  def commands = ""
  pkglist.each { pkg ->
    commands += "RUN mvn org.apache.maven.plugins:maven-dependency-plugin:2.4:get \\\n"
    commands += "        -Dartifact=${pkg}\n"
  }

  from "${projectDir}/src/docker"
  into "${buildDir}/docker"
  filter { String line ->
    if (line.indexOf("@@") >= 0) {
      line = line
        .replace("@@MAVEN-COMMANDS@@", commands)
        .replace("@@VERSION@@", xslTNGversion)
    }
    line
  }
}

task copyReportResources(
  dependsOn: ['copyExpectedMedia', 'zipStageResources', 'zipStageMisc']
) {
  doLast {
    copy {
      from "${projectDir}/src/test/resources"
      include "css/**"
      include "js/**"
      into "${buildDir}/report"
      filter { String line ->
        if (line.indexOf("@@") >= 0) {
          line = line
            .replace("@@TITLE@@", xslTNGtitle)
            .replace("@@VERSION@@", xslTNGversion)
        }
        line
      }
    }
  }
  
  doLast {
    copy {
      from "${buildDir}/stage/zip/resources"
      into "${buildDir}/report/expected"
      exclude "scss/**"
    }
  }
}

task copyTestMedia(type: Copy) {
  from "${projectDir}/src/test/resources"
  into "${buildDir}/actual"
  include "media/**"
}

task copyExpectedMedia(type: Copy) {
  from "${projectDir}/src/test/resources"
  into "${buildDir}/report/expected"
  include "media/**"
}

task allExpectedDocuments() {
  // Just something to hang dependencies on
}

task allExpectedPdfDocuments() {
  // Just something to hang dependencies on
}

task reportExpectedHTML() {
  // Just something to hang dependencies on
}

task validateAll() {
  // Just something to hang dependencies on
}

task generateLocales() {
  // Just something to hang dependencies on
}

task actualResults() {
  // Just somewhere to hang dependencies
}

// ============================================================

// Generate tasks to generate the locale files
fileTree(dir: "${projectDir}/src/main/locale",
         include: "*.xml").each { xml ->
  // Work out the base filename of the test
  def base = TestUtils.fixWindowsPath(xml.toString())
  def pos = base.lastIndexOf("/")
  if (pos > 0) {
    base = base.substring(pos+1)
  }

  Task t = task "locale_${base}"(
    type: SaxonXsltTask
  ) {
    input xml
    stylesheet "${uProjectDir}/src/main/xslt/modules/xform-locale.xsl"
    output "${uBuildDir}/xslt/locale/${base}"

    if (base != 'en.xml') {
      parameters(
        'fallback.locale': "${uProjectDir}/src/main/locale/en.xml"
      )
    }
  }
  generateLocales.dependsOn t
}

task makeVersion(type: SaxonXsltTask) {
  input "${uProjectDir}/tools/version.xsl"
  stylesheet "${uProjectDir}/tools/version.xsl"
  output "${uBuildDir}/xslt/VERSION.xsl"
  parameters(
    'version': xslTNGversion,
    'gitref': gitRef()
  )
}

task copyXslt(dependsOn: ['copyResources', 'makeVersion',
                          'generateLocales', 'compileJava']) {
  inputs.files fileTree(dir: "${projectDir}/src/main/xslt")
  outputs.files fileTree(dir: "${buildDir}/xslt")
  outputs.files fileTree(dir: "${buildDir}/xspec-xslt")

  doLast {
    copy {
      from "${projectDir}/src/main/xslt"
      into "${buildDir}/xslt"
      exclude "xspec-driver.xsl"
      exclude "alt-*.xsl"
    }
  }    

  doLast {
    copy {
      from "${projectDir}/src/main/xslt"
      into "${buildDir}/xspec-xslt"
      include "xspec-driver.xsl"
      include "alt-*.xsl"
    }
  }    
}

task testStandalone(type: SaxonXsltTask) {
  // The output of this test doesn't matter; it simply assures that
  // the standalone-functions.xsl file hasn't accidentally become
  // dependent on other stylesheets so it isn't properly standalone
  inputs.dir "${buildDir}/xslt"
  input "${projectDir}/src/test/resources/xml/article.001.xml"
  stylesheet "${projectDir}/tools/standalone.xsl"
  output "${buildDir}/tmp/standalone.xml"
}

task makeXslt(type: SaxonXsltTask, dependsOn: ["copyXslt"]) {
  input "${projectDir}/src/guide/xml/ref-params.xml"
  stylesheet "${projectDir}/tools/generate-parameters.xsl"
  output "${buildDir}/xslt/param.xsl"
  finalizedBy = [ 'testStandalone' ]
}

task makeUriList(
  dependsOn: ["makeXslt", "zipStageResources","zipStageDocker",
              "zipStageXslt", "zipStageBin"]
) {
  inputs.files fileTree(dir: "${buildDir}/xslt", excludes: ["xspec-*.xsl"])
  inputs.files fileTree("${buildDir}/stage/zip")
  outputs.file "${buildDir}/resources/main/org/docbook/xsltng/etc/uris.xml"

  doFirst {
    mkdir "${buildDir}/resources/main/org/docbook/xsltng/etc"
  }

  doLast {
    def prefix = '/org/docbook/xsltng'
    new File("${buildDir}/resources/main/org/docbook/xsltng/etc/uris.xml").withWriter("utf-8") { writer ->
      writer.writeLine("<catalog>")

      def pos = "${buildDir}".length()
      fileTree(dir: "${buildDir}/xslt", excludes: ["xspec-*.xsl"]).each { file ->
        writer.writeLine("  <uri name='${prefix}${file.getAbsolutePath().substring(pos)}'/>")
      }

      pos = "${buildDir}/stage/zip".length()
      fileTree(dir: "${buildDir}/stage/zip/resources", exclude: ['scss/**']).each { file ->
        writer.writeLine("  <uri name='${prefix}${file.getAbsolutePath().substring(pos)}'/>")
      }
      writer.writeLine("</catalog>")
    }
  }
}

// ============================================================

task formattingTests() {
  // Just somewhere to hang dependencies. I used to put these
  // dependencies directly on 'test', but that had the consequence
  // that running a single unit test ran all of the formatting
  // tests.
}

task testJarMain(type: Exec, dependsOn: jar) {
    commandLine "java",
      "-jar", "${uBuildDir}/libs/docbook-xslTNG-${xslTNGversion}.jar",
      "${uProjectDir}/src/test/resources/xml/article.001.xml",
      "-o:/dev/null"
}
formattingTests.dependsOn testJarMain

task testDocBookPy(type: Exec, dependsOn: ["jar", "copyBin", "copyDocker"]) {
    commandLine "python3", "${buildDir}/bin/docbook",
      "${projectDir}/src/test/resources/xml/article.001.xml",
      "-xsl:${buildDir}/xslt/docbook.xsl",
      "-o:/dev/null"
}
formattingTests.dependsOn testDocBookPy

task testSummary(
  type: SaxonXsltTask,
  dependsOn: ['xspecTests', "makeXslt"]
) {
  inputs.files fileTree(dir: buildDir, include: "*-result.xml")

  stylesheet "${uProjectDir}/tools/test-results.xsl"
  output "${uBuildDir}/test-results.txt"
  args(["-it"])
}

task requirePassingTests(
  type: CheckTextFile,
  dependsOn: ['formattingTests', 'testSummary']
) {
  checkFile = "${buildDir}/test-results.txt"
}
test.dependsOn requirePassingTests

task reportResults(type: Copy, dependsOn: ['testSummary']) {
  from "build"
  include "*-result.*"
  include "*-compiled.xsl"
  into "${buildDir}/report"
}

task coverageReport(type: SaxonXsltTask,
                    dependsOn: ['testSummary', 'copyReportResources']) {
  input "${uBuildDir}/default-result.xml"
  stylesheet "${uProjectDir}/tools/coverage-report.xsl"
  output "${uBuildDir}/report/coverage-report.html"
}
formattingTests.dependsOn reportResults
formattingTests.dependsOn coverageReport

// Use Exec so that it runs the same version of Saxon as the tests.
task report(dependsOn: ['xspecTests']) {
  inputs.files fileTree(dir: buildDir, include: "*-result.xml")
  inputs.file("${projectDir}/tools/report.xsl")
  outputs.file("${buildDir}/report/index.html")
  finalizedBy testSummary

  doLast {
    copy {
      from "${projectDir}/src/test/resources"
      include "css/**"
      include "js/**"
      into "${buildDir}/report"
      filter { String line ->
        if (line.indexOf("@@") >= 0) {
          line = line
            .replace("@@TITLE@@", xslTNGtitle)
            .replace("@@VERSION@@", xslTNGversion)
        }
        line
      }
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/website/resources"
      include "img/**"
      include "media/**"
      exclude "olinkdb/**"
      into "${buildDir}/report"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/test/resources"
      include "xml/**"
      include "expected/**"
      filter { String line ->
        if (line.indexOf("@@") >= 0) {
          line = line
            .replace("@@TITLE@@", xslTNGtitle)
            .replace("@@VERSION@@", xslTNGversion)
        }
        line
      }
      into "${buildDir}/report"
    }
  }

  doLast {
    copy {
      from "${buildDir}/validated"
      into "${buildDir}/report/xml"
    }
  }

  doLast {
    copy {
      from "build"
      include "*-result.*"
      include "*-compiled.xsl"
      into "${buildDir}/report"
    }
  }

  doLast {
    exec {
      commandLine "java",
        "-Dorg.docbook.xsltng.extensions.verbose=${verbose}",
        "-Dorg.docbook.extensions.pygmentize=${pygmentize}",
        "-cp", EXCP, "net.sf.saxon.Transform",
        "-init:org.docbook.xsltng.extensions.Register",
        "${buildDir}/default-result.xml",
        "-xsl:tools/report.xsl",
        "-o:${buildDir}/report/index.html"
    }
  }
}

// ============================================================

task cleanXSpec() {
  doLast {
    fileTree(dir: buildDir, exclude: ["xspec-" + xspecVersion + ".zip",
                                      "xspec-" + xspecVersion + "/**",
                                      "docbook-" + docbookVersion + ".zip",
                                      "docbook-" + docbookVersion + "/**"])
      .each { artifact ->
        artifact.delete()
      }
  }
}
clean.dependsOn cleanXSpec

// ============================================================

task zipStagePygments() {
  if (pygmentize == "") {
    doLast {
      println("Without pygmentize, zip file resources will be incomplete.")
    }
  } else {
    doFirst {
      mkdir "${buildDir}/stage/zip/resources/css"
    }
    doLast {
      exec {
        commandLine "python3", "${uProjectDir}/tools/generate-pygments.py",
          "--version", xslTNGversion, "--title", xslTNGtitle,
          "--output", "${buildDir}/stage/zip/resources/css/pygments.css"
      }
    }
  }
}

task compileSass() {
  inputs.files fileTree("${projectDir}/src/main/scss")
  outputs.files fileTree("${buildDir}/css")

  doLast {
    exec {
      commandLine 'sass', '--style', 'expanded',
        '--no-source-map', '--no-charset',
        "${fProjectDir}/src/main/scss/docbook-screen.scss:${buildDir}/css/docbook.css",
        "${fProjectDir}/src/main/scss/docbook-paged.scss:${buildDir}/css/docbook-paged.css",
        "${fProjectDir}/src/main/scss/docbook-epub.scss:${buildDir}/css/docbook-epub.css",
        "${fProjectDir}/src/main/scss/toc.scss:${buildDir}/css/docbook-toc.css",
        "${fProjectDir}/src/main/scss/vendor-ahf-portrait.scss:${buildDir}/css/vendor-ahf-portrait.css",
        "${fProjectDir}/src/main/scss/vendor-ahf-landscape.scss:${buildDir}/css/vendor-ahf-landscape.css",
        "${fProjectDir}/src/main/scss/vendor-weasyprint.scss:${buildDir}/css/vendor-weasyprint.css"
    }
  }

  doLast {
    exec {
      commandLine 'sass', '--style', 'compressed',
        '--no-source-map', '--no-charset',
        "${fProjectDir}/src/main/scss/docbook-screen.scss:${buildDir}/css/docbook.min.css",
        "${fProjectDir}/src/main/scss/docbook-paged.scss:${buildDir}/css/docbook-paged.min.css",
        "${fProjectDir}/src/main/scss/docbook-epub.scss:${buildDir}/css/docbook-epub.min.css",
        "${fProjectDir}/src/main/scss/toc.scss:${buildDir}/css/docbook-toc.min.css",
        "${fProjectDir}/src/main/scss/vendor-ahf-portrait.scss:${buildDir}/css/vendor-ahf-portrait.min.css",
        "${fProjectDir}/src/main/scss/vendor-ahf-landscape.scss:${buildDir}/css/vendor-ahf-landscape.min.css",
        "${fProjectDir}/src/main/scss/vendor-weasyprint.scss:${buildDir}/css/vendor-weasyprint.min.css"
    }
  }

  doLast {
    ["docbook", "docbook-paged", "docbook-epub", "docbook-toc",
     "vendor-ahf-landscape", "vendor-ahf-portrait", "vendor-weasyprint"].each { base ->
      [".css", ".min.css"].each { ext ->
        String fn = "${base}${ext}"
        File css = new File("${buildDir}/css/${fn}")
        def lines = []
        def reader = new BufferedReader(new FileReader(css))
        String line = null
        while ((line = reader.readLine()) != null) {
          lines.add(line)
        }
        reader.close()
        def writer = new PrintStream(css)
        writer.print("/")
        writer.print("* ${xslTNGtitle} version ${xslTNGversion}, https://xsltng.docbook.org *")
        if (ext == ".css") {
          writer.println("/");
        } else {
          writer.print("/");
        }
        lines.each { ln ->
          writer.println(ln);
        }
        writer.close();
      }
    }
  }
}

task zipStageResources(dependsOn: ["zipStagePygments", "compileSass"]) {
  doLast {
    copy {
      from "${buildDir}/css"
      into "${buildDir}/stage/zip/resources/css"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/main/scss"
      into "${buildDir}/stage/zip/resources/scss"
    }
  }

  // Copy png files without filtering them
  doLast {
    copy {
      from "${projectDir}/src/main/web"
      include "css/*.png"
      into "${buildDir}/stage/zip/resources"
    }
  }

  // Copy and filter text resources
  doLast {
    copy {
      from "${projectDir}/src/main/web"
      include 'css/**'
      include 'js/**'
      exclude 'css/*.png'

      if (pygmentize != "") {
        exclude 'css/pygments.css'
      }

      into "${buildDir}/stage/zip/resources"
      filter { String line ->
        if (line.indexOf("@@") >= 0) {
          line = line
            .replace("@@TITLE@@", xslTNGtitle)
            .replace("@@VERSION@@", xslTNGversion)
        }
        line
      }
    }
  }
}

task zipStageSamples(dependsOn: ["zipStageResources"]) {
  doLast {
    copy {
      from "${buildDir}/stage/zip/resources"
      into "${buildDir}/stage/zip/samples"
      exclude "scss/**"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/main/samples"
      into "${buildDir}/stage/zip/samples"
    }
  }
}

task zipStageXslt(type: Copy, dependsOn: ['makeXslt']) {
  from "${buildDir}/xslt"
  into "${buildDir}/stage/zip/xslt"
}

task zipStageMisc(type: Copy, dependsOn: ["zipStageSamples"]) {
  from "."
  into "${buildDir}/stage/zip"
  include "README.md"
  include "LICENSE"
}

task zipStageLib(dependsOn: ['jar', 'copyLib']) {
  doLast {
    copy {
      from "${buildDir}/libs"
      into "${buildDir}/stage/zip/libs"
      include "docbook-xslTNG-${xslTNGversion}.jar"
    }
  }
  doLast {
    copy {
      from "${buildDir}/libs/lib"
      into "${buildDir}/stage/zip/libs/lib"
    }
  }
}

task zipStageBin(type: Copy, dependsOn: ['copyBin']) {
  from "${buildDir}/bin"
  into "${buildDir}/stage/zip/bin"
}

task zipStageDocker(type: Copy, dependsOn: ['copyDocker']) {
  from "${buildDir}/docker"
  into "${buildDir}/stage/zip/docker"
}

task zipStageCatalog(
  type: SaxonXsltTask,
  dependsOn: ['makeUriList', 'zipStageXslt', "stageJar", "processResources"]
) {
  input TestUtils.fixWindowsPath(makeUriList.outputs.files.getSingleFile().toString())
  stylesheet "${uProjectDir}/src/main/resources/org/docbook/xsltng/etc/make-catalog.xsl"
  output "${uBuildDir}/stage/zip/xslt/catalog.xml"
  parameters(
    'version': xslTNGversion
  )
}

task zipStage(type: Copy, dependsOn: ['zipStageBin', 'zipStageDocker', 'zipStageLib',
                                      'zipStageMisc', 'zipStageCatalog']) {
  // nop
}

task releaseArtifacts(type: Copy, dependsOn: ['zipStage']) {
  from "${buildDir}/stage/zip"
  into "${buildDir}/release"
  exclude "bin/**"
  exclude "libs/**"
  exclude "samples/**"
  exclude "docker/**"
}

task zipDist(type: Zip, dependsOn: ['zipStage']) {
  from("${buildDir}/stage/zip")
  into "${xslTNGbaseName}-${xslTNGversion}"
  archiveFileName = "${xslTNGbaseName}-${xslTNGversion}.zip"
}

task zipDistNoSaxon(type: Zip, dependsOn: ['zipStage']) {
  from("${buildDir}/stage/zip")
  exclude "libs/lib/Saxon*"
  into "${xslTNGbaseName}-nosaxon-${xslTNGversion}"
  archiveFileName = "${xslTNGbaseName}-nosaxon-${xslTNGversion}.zip"
}

task relnotes(
  description: "Checks for release notes",
) {
  doLast {
    BufferedReader guide = new BufferedReader(new FileReader("${projectDir}/src/guide/xml/changelog.xml"))
    boolean found = false
    String line = guide.readLine()
    while (line != null) {
      if (line.contains("<productnumber>${xslTNGversion}<")) {
        found = true;
        break;
      }
      line = guide.readLine()
    }
    guide.close();

    if (!found) {
      println("************************************************************")
      println("There are no release notes for xslTNG version ${xslTNGversion}")
      println("************************************************************")
      if (requireCompileSuccess && !xslTNGversion.contains('SNAPSHOT')) {
        throw new GradleException("No release notes for ${xslTNGversion}")
      }
    }
  }
}

// ============================================================

task dist(
  dependsOn: ['requirePassingTests', 'releaseArtifacts',
              'zipDist', 'zipDistNoSaxon', 'website', 'relnotes']
) {
  doLast {
    println("Built dist for ${xslTNGtitle} version ${xslTNGversion}")
  }
}

// ============================================================

task explorer(type: SaxonXsltTask,
              dependsOn: ['makeXslt',
                          'setupXsltExplorer', 'explorerResources']) {
  inputs.files fileTree(dir: "${buildDir}/xslt", excludes: ["xspec-*.xsl"])
  outputs.file("${buildDir}/docbook-xslTNG.xml")

  input "${uBuildDir}/xslt/docbook.xsl"
  stylesheet "${uBuildDir}/xsltexplorer-${xsltExplorerVersion}/xslt/explorer.xsl"
  output "${uBuildDir}/explorer/index.html"
  args docbookXsltArgs
  arg '-l:on'
  parameters(
    'debug-analyze': "${uBuildDir}/docbook-xslTNG.xml"
  )
}

task explorerResources(type: Copy, dependsOn: ['setupXsltExplorer']) {
  into "${buildDir}/explorer"
  from "${buildDir}/xsltexplorer-${xsltExplorerVersion}"
  include "css/**"
  include "js/**"
}

task guideResources(dependsOn: ['guideDocBookResources','guideCustomResources']) {
  // nop
}

task guideDocBookResources(type: Copy, dependsOn: ['copyResources', 'explorer']) {
  from "${buildDir}/actual"
  include "css/**"
  include "js/**"
  exclude "css/print.css"
  into "${buildDir}/guide/"
}

task guideCustomResources(type: Copy) {
  from "${projectDir}/src/guide/resources"
  include "css/**"
  include "js/**"
  include "media/**"
  include "*.html"
  into "${buildDir}/guide/"
}

task prepareToXIncludeGuideCopy(type: Copy) {
  from "${projectDir}/src/guide/xml"
  into "${buildDir}/tmp/guide"
  exclude "ref-params.xml"
}

task prepareToXIncludeGuideTransform(type: SaxonXsltTask) {
  input "${uProjectDir}/src/guide/xml/ref-params.xml"
  stylesheet "${uProjectDir}/tools/generate-ref-params.xsl"
  output "${uBuildDir}/tmp/guide/ref-params.xml"
}

task xincludeGuide(type: SaxonXsltTask,
                   dependsOn: ['guideResources', 'prepareToXIncludeGuideCopy',
                               'prepareToXIncludeGuideTransform']) {
  inputs.files fileTree(dir: "${buildDir}/tmp/guide")
  inputs.file "${projectDir}/tools/xinclude.xsl"

  input "${uBuildDir}/tmp/guide/guide.xml"
  stylesheet "${uProjectDir}/tools/xinclude.xsl"
  output "${uBuildDir}/guide.xml"
  args docbookXsltArgs
}

task copyGuide(type: SaxonXsltTask, dependsOn: ['xincludeGuide']) {
  input "${uBuildDir}/guide.xml"
  stylesheet "${uProjectDir}/tools/guide-pis.xsl"
  output "${uBuildDir}/guide/guide.xml"
}

task validateGuide(type: RelaxNGValidateTask, dependsOn: ['copyGuide']) {
  input "${uBuildDir}/guide/guide.xml"
  schema "${uProjectDir}/src/test/resources/docbook.rng"
  output "${uBuildDir}/guide/validated.xml"
}

task guide(
  type: SaxonXsltTask,
  dependsOn: ['makeXslt', 'validateGuide', 'explorer']
) {
  inputs.files fileTree(dir: "${buildDir}/xslt", excludes: ["xspec-*.xsl"])
  inputs.files fileTree(dir: "${projectDir}/src/guide/xml")
  inputs.files fileTree(dir: "${projectDir}/src/guide/xsl")
  inputs.file("${buildDir}/docbook-xslTNG.xml")
  outputs.file("${buildDir}/guide/index.html")

  input "${uBuildDir}/guide/guide.xml"
  stylesheet "${uProjectDir}/src/guide/xsl/guide.xsl"
  output "${uBuildDir}/guide/irrelevant-and-deleted-file.html"
  args docbookXsltArgs
  parameters(
    'explorer.xml': "${uBuildDir}/docbook-xslTNG.xml",
    'bookVersion': guideVersion,
    'xslTNGversion': xslTNGversion,
    'profile-outputformat': 'online',
    'pagetoc-elements': 'preface chapter appendix refentry',
    'chunk': 'index.html',
    'chunk-output-base-uri': "${uProjectDir}/build/guide/"
  )

  doLast {
    delete "${uBuildDir}/guide/irrelevant-and-deleted-file.html"
  }
}

task guide_fonts(
  type: Copy
) {
  from "${projectDir}/src/guide/resources/fonts"
  into "${buildDir}/guide/css/fonts"
  include "**/*.ttf"
  eachFile {
    path = name
  }
  includeEmptyDirs = false
}

task "guide.pdf.html"(
  type: SaxonXsltTask,
  dependsOn: ['makeXslt', 'validateGuide', 'explorer', 'guide_fonts']
) {
  inputs.files fileTree(dir: "${buildDir}/xslt", excludes: ["xspec-*.xsl"])
  inputs.file "${buildDir}/docbook-xslTNG.xml"
  inputs.files fileTree(dir: "${projectDir}/src/guide/xsl")

  input "${uBuildDir}/guide/guide.xml"
  stylesheet "${uProjectDir}/src/guide/xsl/print.xsl"
  output "${uBuildDir}/guide/guide.pdf.html"
  args docbookXsltArgs
  parameters(
    'explorer.xml': "${uBuildDir}/docbook-xslTNG.xml",
    'bookVersion': guideVersion,
    'xslTNGversion': xslTNGversion,
    'profile-outputformat': 'print',
    'page-style': 'book',
    'resource-base-uri': ''
  )
}

if (pdftool == "prince") {
  task "guide.pdf"(type: Exec, dependsOn: ["guide.pdf.html"]) {
    inputs.file("${buildDir}/guide/guide.pdf.html")
    inputs.files fileTree(dir: "${buildDir}/guide/css")
    outputs.file("${buildDir}/guide/guide.pdf")
    commandLine "${prince}",
      "${buildDir}/guide/guide.pdf.html",
      "-o", "${buildDir}/guide/guide.pdf"
  }
} else if (pdftool == "antennahouse") {
  task "guide.pdf"(type: Exec, dependsOn: ["guide.pdf.html"]) {
    inputs.file("${buildDir}/guide/guide.pdf.html")
    inputs.files fileTree(dir: "${buildDir}/guide/css")
    outputs.file("${buildDir}/guide/guide.pdf")
    commandLine "${antennahouse}",
      "-d", "${buildDir}/guide/guide.pdf.html",
      "-o", "${buildDir}/guide/guide.pdf"
  }
} else if (pdftool == "vivliostyle") {
  task "guide.pdf"(type: Exec, dependsOn: ["guide.pdf.html"]) {
    inputs.file("${buildDir}/guide/guide.pdf.html")
    inputs.file("${buildDir}/vivliostyle.config.js")
    inputs.files fileTree(dir: "${buildDir}/guide/css")
    outputs.file("${buildDir}/guide/guide.pdf")
    commandLine "${vivliostyle}",
      "build", "${buildDir}/guide/guide.pdf.html",
      "-o", "${buildDir}/guide/guide.pdf"
  }
} else if (pdftool == "weasyprint") {
  task "guide.pdf"(type: Exec, dependsOn: ["guide.pdf.html"]) {
    inputs.file("${buildDir}/guide/guide.pdf.html")
    inputs.files fileTree(dir: "${buildDir}/guide/css")
    outputs.file("${buildDir}/guide/guide.pdf")
    commandLine "${weasyprint}",
      "${buildDir}/guide/guide.pdf.html",
      "${buildDir}/guide/guide.pdf"
  }
} else {
  throw new GradleException("Unknown pdftool: " + pdftool)
}

task "guide.olinkdb"(type: SaxonXsltTask, dependsOn: ['guide']) {
  inputs.files fileTree(dir: "${buildDir}/xslt", excludes: ["xspec-*.xsl"])
  inputs.files fileTree(dir: "${projectDir}/src/guide/xsl")
  inputs.file("${buildDir}/docbook-xslTNG.xml")

  input "${buildDir}/guide/guide.xml"
  stylesheet "${buildDir}/xslt/olinkdb.xsl"
  output "${buildDir}/actual/guide.olinkdb"
  args docbookXsltArgs
  parameters(
    'explorer.xml': "${buildDir}/docbook-xslTNG.xml",
    'bookVersion': guideVersion,
    'xslTNGversion': xslTNGversion,
    'profile-outputformat': 'online',
    'chunk': 'index.html',
    'chunk-output-base-uri': "https://xsltng.docbook.org/guide/",
    'olink-targetdoc': 'Guide'
  )
}

// ============================================================

task website(type: Copy, dependsOn: ['webGuide', 'webReport', 'webExplorer',
                                     'webHtml', 'webResources', 'epubGuide']) {
  into "${buildDir}/website/epub"
  from "${buildDir}/epub"
  include "*.epub"
  rename { filename ->
    "DocBook-${filename}"
  }
}

task webGuide(
  dependsOn: ['guide', 'guide.olinkdb']
) {
  inputs.dir "${buildDir}/guide"
  outputs.dir "${buildDir}/website/guide/${guideVersion}"
  outputs.file "${buildDir}/website/guide/index.html"
  outputs.file "${buildDir}/website/epub/index.html"

  doLast {
    copy {
      from "${buildDir}/guide"
      exclude "guide.xml"
      exclude "validated.xml"
      into "${buildDir}/website/guide/${guideVersion}"
    }
  }

  doLast {
    if (!guidePrerelease) {
      File html = new File("${buildDir}/website/guide/index.html")
      def writer = new PrintStream(html)
      writer.println('<!DOCTYPE html>')
      writer.println('<html>')
      writer.println('<head>')
      writer.println("<meta http-equiv='refresh' content=\"0; url='${guideVersion}/'\" />")
      writer.println('</head>')
      writer.println('<body>')
      writer.println('<p>The current guide is ')
      writer.println("<a href='${guideVersion}/'>version ${guideVersion}</a>.</p>")
      writer.println('</body>')
      writer.println('</html>')
      writer.close()

      mkdir("${buildDir}/website/epub")
      def epub = "DocBook-xslTNG-${guideVersion}.epub"
      html = new File("${buildDir}/website/epub/index.html")
      writer = new PrintStream(html)
      writer.println('<!DOCTYPE html>')
      writer.println('<html>')
      writer.println('<head>')
      writer.println("<meta http-equiv='refresh' content=\"0; url='${epub}'\" />")
      writer.println('</head>')
      writer.println('<body>')
      writer.println('<p>The current EPUB guide is ')
      writer.println("<a href='${epub}'>version ${guideVersion}</a>.</p>")
      writer.println('</body>')
      writer.println('</html>')
      writer.close()
    }
  }
}

task webExplorer(type: Copy, dependsOn: ['explorer']) {
  from "${buildDir}/explorer"
  into "${buildDir}/website/explorer"
}

task webReport(type: Copy, dependsOn: ['report', 'copyReportResources', 'copyExpectedMedia',
                                       'reportResults', 'coverageReport']) {
  from "${buildDir}/report"
  into "${buildDir}/website/report"
}

task webResources(type: Copy, dependsOn: ['report']) {
  from "${projectDir}/src/website/resources/"
  into "${buildDir}/website"
  exclude "images/**"
  exclude "olinkdb/**"
}

task webHtml(type: Copy, dependsOn: ['report', 'webHomepage']) {
  from "${projectDir}/src/website/html"
  into "${buildDir}/website"
  exclude "homepage.html"
}

def buildTag = System.getenv()["CI_TAG"]
if (buildTag == null) {
  buildTag = ""
}
task webHomepage(type: SaxonXsltTask, dependsOn: ['testSummary']) {
  input "${uProjectDir}/src/website/html/homepage.html"
  stylesheet "${uProjectDir}/tools/homepage.xsl"
  output "${uBuildDir}/website/index.html"
  parameters(
    "build-tag": buildTag
  )
}

// ============================================================

task copyLib() {
  String path = ""
  configurations.projectImplementationClasspath.each { file ->
    path += " lib/" + file.name
    if (file.name.endsWith(".jar")) {
      doLast {
        copy {
          from file
          into "${buildDir}/libs/lib"
        }
      }
    }
  }
  project.ext.runtimeClasspath = path.trim()
}
jar.dependsOn copyLib

task makeVersionProperties() {
  outputs.file "${buildDir}/resources/main/org/docbook/xsltng/etc/version.properties"

  doFirst {
    mkdir("${buildDir}/resources/main/org/docbook/xsltng/etc")
  }
  doLast {
    new File("${buildDir}/resources/main/org/docbook/xsltng/etc/version.properties").withWriter("utf-8") { writer ->
      writer.writeLine("version=${xslTNGversion}")
    }
  }
}

task jarStageCatalog(
  dependsOn: ['jarStageCatalog_xslt', 'jarStageCatalog_resolver']
) {
  // just somewhere to hang dependencies
}

task jarStageCatalog_xslt(type: SaxonXsltTask, dependsOn: ['makeUriList']) {
  input makeUriList.outputs.files.getSingleFile()
  stylesheet "${uProjectDir}/src/main/resources/org/docbook/xsltng/etc/make-catalog.xsl"
  output "${uBuildDir}/resources/main/org/docbook/xsltng/catalog.xml"
  parameters(
    'version': xslTNGversion,
    'jarloc': 'classpath:org/docbook/xsltng/'
  )
  doLast {
    copy {
      into "${buildDir}/resources/main/org/xmlresolver"
      from ("${buildDir}/resources/main/org/docbook/xsltng") {
        include "catalog.xml"
      }
    }
  }
}

task jarStageCatalog_resolver(type: SaxonXsltTask, dependsOn: ['makeUriList']) {
  input makeUriList.outputs.files.getSingleFile()
  stylesheet "${uProjectDir}/src/main/resources/org/docbook/xsltng/etc/make-catalog.xsl"
  output "${uBuildDir}/resources/main/org/xmlresolver/catalog.xml"
  parameters(
    'version': xslTNGversion,
    'jarloc': 'classpath:org/docbook/xsltng/'
  )
  doLast {
    copy {
      into "${buildDir}/resources/main/org/xmlresolver"
      from ("${buildDir}/resources/main/org/docbook/xsltng") {
        include "catalog.xml"
      }
    }
  }
}

task stageJar(
  dependsOn: ["makeXslt", "makeVersionProperties", "makeUriList", "jarStageCatalog",
              "zipStagePygments"]
) {
  inputs.files fileTree(dir: "${projectDir}/buildSrc/build/classes/java/main")
  inputs.files fileTree(dir: "${projectDir}/buildSrc/build/classes/java/groovy")
  inputs.files fileTree(dir: "${buildDir}/stage/zip/resources")
  inputs.files fileTree(dir: "${buildDir}/xslt", excludes: ["xspec-*.xsl"])
  outputs.files fileTree(dir: "${buildDir}/resources/main")

  doLast {
    copy {
      into "${buildDir}/resources/main"
      from "${projectDir}/buildSrc/build/classes/java/main"
    }
    copy {
      into "${buildDir}/resources/main/org/docbook/xsltng/resources"
      from "${buildDir}/stage/zip/resources"
      include "css/**"
      include "js/**"
    }
    // Not ${buildDir}/classes/java/main because the jar task
    // picks those up automatically and we don't want duplicates
    copy {
      into "${buildDir}/resources/main/org/docbook/xsltng/xslt"
      from "${buildDir}/xslt"
    }
  }
}
processResources.dependsOn stageJar

jar {
  archiveBaseName = "docbook-xslTNG-${xslTNGversion}"
  manifest {
    attributes "Built-By": "Norman Walsh"
    attributes "Implementation-Vendor": "Norman Walsh"
    attributes "Implementation-Title": "DocBook xslTNG Stylesheets"
    attributes "Implementation-Version": xslTNGversion
    attributes "Main-Class": "org.docbook.xsltng.Main"
    attributes "Bundle-SymbolicName": "org.docbook.xsltng"
    attributes "Bundle-RequiredExecutionEnvironment": "J2SE-1.7"
    attributes "Export-Package": "*: etc"
    attributes "Import-Package": "net.sf.saxon.*;version=${saxonVersion}:\
  javax.xml.*:\
  *;resolution:=optional"
    attributes "DynamicImport-Package": "*"
    // This is a bit of a hack; special case the three most likely
    // commercial jar files for printing with CSS or FO.
    attributes "Class-Path": project.ext.runtimeClasspath \
              + " lib/XfoJavaCtl.jar lib/xep.jar lib/prince.jar"
  }
  from "${buildDir}/resources/main"
}

task javadocJar(type: Jar, dependsOn: javadoc) {
  archiveClassifier = 'javadoc'
  from javadoc.destinationDir
}

task sourcesJar(type: Jar) {
  archiveClassifier = 'sources'
  from sourceSets.main.allSource
}

// ============================================================

signing {
  sign publishing.publications
}

publishing {
  publications {
    mavenJava(MavenPublication) {
      pom {
        name = xslTNGtitle
        packaging = 'jar'
        description = 'DocBook xslTNG Stylesheets'
        url = 'https://github.com/docbook/xslTNG'

        scm {
          url = 'scm:git@github.com:docbook/xslTNG.git'
          connection = 'scm:git@github.com:docbook/xslTNG.git'
          developerConnection = 'scm:git@github.com:docbook/xslTNG.git'
        }

        licenses {
          license {
            name = 'Apache License version 2.0'
            url = 'https://www.apache.org/licenses/LICENSE-2.0'
            distribution = 'repo'
          }
        }

        developers {
          developer {
            id = 'ndw'
            name = 'Norman Walsh'
          }
        }
      }

      groupId = "org.docbook"
      artifactId = "docbook-xslTNG"
      version = xslTNGversion
      from components.java
      artifact javadocJar
      artifact sourcesJar
    }
  }

  repositories {
    maven {
      url = xslTNGversion.contains("SNAPSHOT") ?
        "https://oss.sonatype.org/content/repositories/snapshots/" :
        "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
      credentials {
        username = findProperty("sonatypeUsername") ?: ""
        password = findProperty("sonatypePassword") ?: ""
      }
    }
  }
}

// ============================================================

task epubGuideResources(
  dependsOn: ["copyResources"]
) {
  inputs.files fileTree(dir: "${buildDir}/actual/css")
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/fonts")
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/css")
  outputs.files fileTree(dir: "${buildDir}/epub/OPS/css")

  doLast {
    copy {
      from "${buildDir}/actual/css"
      into "${buildDir}/epub/OPS/css"
      include "docbook-epub.css"
      include "draft*.svg"
      include "draft*.png"
      include "pygments.css"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/guide/resources/css"
      into "${buildDir}/epub/OPS/css"
      include "guide-epub.css"
    }
  }

  doLast {
    copy {
      from "${projectDir}/src/guide/resources/fonts"
      into "${buildDir}/epub/OPS/css/fonts"
      include "**/*.ttf"
      exclude "**/*ExtraBold*"
      exclude "**/*SemiBold*"
      exclude "**/*Light*"
      exclude "**/*Thin*"
      eachFile {
        path = name
      }
      includeEmptyDirs = false
    }
  }
}

task epubGuideMedia(
  dependsOn: ["epubGuideResources"]
) {
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/css")
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/media")
  inputs.files fileTree(dir: "${projectDir}/src/guide/resources/media")
  outputs.files fileTree(dir: "${buildDir}/epub/OPS/css")
  outputs.files fileTree(dir: "${buildDir}/epub/OPS/media")
  outputs.file "${buildDir}/epub/manifest-extra.xml"

  doLast {
    copy {
      into "${buildDir}/epub/OPS/css"
      from "${projectDir}/src/guide/resources/css"
      exclude "guide-paged.css"
    }
  }

  doLast {
    copy {
      into "${buildDir}/epub/OPS/media"
      from "${projectDir}/src/guide/resources/media"
    }
  }

  doLast {
    def m = new PrintStream(new File("${buildDir}/epub/manifest-extra.xml"))
    m.println("<manifest xmlns='http://www.idpf.org/2007/opf'>")
    fileTree(dir: "${buildDir}/epub/OPS",
             includes: ["media/**", "css/**"]).each { rsrc ->
      String href = TestUtils.fixWindowsPath(rsrc.toString())
      int pos = href.indexOf("/OPS/")
      href = href.substring(pos+5)
      String id = href.replaceAll("/", "_")

      pos = href.lastIndexOf(".")
      String ext = href.substring(pos+1)
      String mediaType = "application/octet-stream"

      if (epubMediaTypes[ext] != null) {
        mediaType = epubMediaTypes[ext]
      } else {
        println("Warning: Unknown media type: ${href}")
      }

      m.print("<item id='id_${id}' href='${href}' media-type='${mediaType}'")
      if (mediaType == 'image/svg') {
        m.print(" fallback='id_${id.replaceAll('.svg$', '.png')}'")
      }
      if (mediaType.startsWith('image/') && href.startsWith('media/cover.')) {
        m.print(" properties='cover-image'")
      }
      m.println("/>")
    }
    m.println("</manifest>")
    m.close()
  }
}

task epubGuideFormat(
  type: SaxonXsltTask,
  dependsOn: ['makeXslt', 'validateGuide', 'explorer', 'epubGuideMedia']
) {
  inputs.files fileTree(dir: "${buildDir}/xslt", excludes: ["xspec-*.xsl"])
  inputs.files fileTree(dir: "${projectDir}/src/guide/xsl")
  inputs.file "${buildDir}/guide/guide.xml"
  outputs.files fileTree(dir: "${buildDir}/epub")

  input "${uBuildDir}/guide/guide.xml"
  stylesheet "${uProjectDir}/src/guide/xsl/epub.xsl"
  output "${uBuildDir}/epub/mimetype"
  args docbookXsltArgs
  parameters(
    'profile-outputformat': 'online',
    'chunk': 'titlepage.xhtml',
    'chunk-output-base-uri': "${uBuildDir}/epub/",
    'explorer.xml': "${uBuildDir}/docbook-xslTNG.xml",
    'bookVersion': guideVersion,
    'xslTNGversion': xslTNGversion,
    'pub-id': "xslTNG-guide-${guideVersion}",
    'manifest-extra': "${uBuildDir}/epub/manifest-extra.xml"
  )
}

task epubGuide(
  dependsOn: ["epubGuideResources", "epubGuideMedia", "epubGuideFormat"]
) {
  inputs.files fileTree(dir: "${buildDir}/epub", exclude: "*.epub")
  outputs.file "${buildDir}/epub/xslTNG-${guideVersion}.epub"

  def epub_file = epubGuide.outputs.files.getSingleFile().toString()

  doFirst {
    delete epub_file
  }
  
  doLast {
    // What on earth is this, I hear you ask? Well, I can't find any way
    // to make the Gradle Zip task produce a ZIP archive containing one
    // stored file and a bunch of compressed files. And I'm trying to
    // avoid a dependency on an external "zip" program in order to
    // make the script easier to run on multiple operating (*cough* Windows)
    // systems.

    def fileList = []
    def rootdir = "${buildDir}/epub"
    fileTree(rootdir).each { file ->
      def filename = file.toString().substring(rootdir.length()+1).replace('\\', '/')
      if (filename.startsWith('OPS/') || filename.startsWith('META-INF/')) {
        fileList.add(filename)
      }
    }

    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(epub_file))

    FileInputStream es = new FileInputStream("${buildDir}/epub/mimetype")
    byte[] buffer = new byte[4096]
    int len = es.read(buffer)
    es.close()

    // ATTENTION: The mimetype entry is magic, we know its size and CRC
    // without computing them because its content is fixed by the standard
    ZipEntry zipEntry = new ZipEntry("mimetype")
    zipEntry.setMethod(ZipEntry.STORED)
    zipEntry.setSize(20)
    zipEntry.setCompressedSize(20)
    zipEntry.setCrc(749429103)
    zip.putNextEntry(zipEntry)
    zip.write(buffer, 0, len)
    zip.closeEntry()

    fileList.each { filename ->
      zipEntry = new ZipEntry(filename)
      zip.putNextEntry(zipEntry)

      es = new FileInputStream("${buildDir}/epub/${filename}")
      while ((len = es.read(buffer)) >= 0) {
        zip.write(buffer, 0,len)
      }
      es.close()
      zip.closeEntry()
    }
    zip.close()
  }

  doLast {
    javaexec {
      classpath = configurations.projectImplementationClasspath
      mainClass = 'com.adobe.epubcheck.tool.Checker'
      args epub_file
    }
  }
}

// ============================================================
// Down here so that it comes after all the other tasks have
// been registered/created

task xspecTests() {
  // Just somewhere to hang dependencies
}

// We begin with a couple of manual tests
// We make xspecTests depend on these so that they run, but they
// aren't really XSpec tests. Considerr refactoring the test
// tasks someday.

task testRngValidation(
  type: SaxonXsltTask,
  dependsOn: ["makeXslt"]
) {
  outputs.upToDateWhen { false }
  input "${uProjectDir}/src/test/resources/xml/article.001.xml"
  stylesheet "${uBuildDir}/xslt/docbook.xsl"
  output "${uBuildDir}/tmp/rng-validation-test.html"
  args docbookXsltArgs
  parameters(
    'relax-ng-grammar': "${uProjectDir}/src/test/resources/docbook.rng"
  )
}
xspecTests.dependsOn testRngValidation

task testRncValidation(
  type: SaxonXsltTask,
  dependsOn: ["makeXslt"]
) {
  outputs.upToDateWhen { false }
  input "${uProjectDir}/src/test/resources/xml/article.001.xml"
  stylesheet "${uBuildDir}/xslt/docbook.xsl"
  output "${uBuildDir}/tmp/rng-validation-test.html"
  args docbookXsltArgs
  parameters(
    'relax-ng-grammar': "${uProjectDir}/src/test/resources/docbook.rnc"
  )
}
xspecTests.dependsOn testRncValidation

// Then the generated ones

TestGenerator testGenerator = new TestGenerator(project)
//testGenerator.configure(new File("${projectDir}/src/test/resources/xml/para.002.xml"))
fileTree(
  dir: "${projectDir}/src/test/resources/xml",
  include: '*.xml',
  exclude: ['tran-caution.xml', 'epub.001.xml']
).each { xml ->
  testGenerator.configure(xml)
}
testGenerator.createTasks()

testSummary.dependsOn project.tasks.named("all_mo_tests")
report.dependsOn project.tasks.named("all_mo_tests")

// These are the xspec files authored by hand for whatever reason
fileTree(dir: "${projectDir}/src/test/xspec", include: "*.xspec").each { xspec ->
  String fn = xspec.toString().replace('\\', '/').split('/')[-1]
  String base = fn.replaceFirst('\\.xspec$', '')
  def task = tasks.register("${base}.xspec", Exec) {
    inputs.files project.fileTree(dir: "${projectDir}/src/main/xslt")
    inputs.files project.fileTree(dir: "${projectDir}/src/test/resources/xml")
    inputs.file xspec
    dependsOn tasks.named('copyXslt')

    outputs.file project.file("${buildDir}/${base}-compiled.xsl")
    outputs.file project.file("${buildDir}/${base}-result.html")
    outputs.file project.file("${buildDir}/${base}-result.xml")
    commandLine "${project.buildDir}/xspec-${xspecVersion}/bin/${XSPEC}",
      xspec.toString()
  }
  tasks.named("xspecTests").configure {
    dependsOn task
  }
}

// Generate tasks to construct the generated tests
fileTree(dir: "${projectDir}/src/test/generators").each { xsl ->
  def xspec = TestUtils.fixWindowsPath(xsl.toString())
                 .replace('/generators/', '/xspec/generated-')
                 .replace('.xsl', '.xspec')
  def name  = xspec.replace('.xspec', '')
                 .replace('/', '_')
                 .replace('.', '_')
                 .replace('-', '_')

  // Shorten the name a little if possible
  def pos = name.indexOf('generated_')
  if (pos > 0) {
    name = name.substring(pos)
  }

  // Work out the base filename of the test
  def base = xspec
  pos = base.indexOf('/test/xspec/')
  if (pos > 0) {
    base = base.substring(pos+12)
    base = base.replace('.xspec', '')
  }

  def generator = name + '_gen'
  def taskname = name + '.xspec'

  def g = project.tasks.register("${generator}", SaxonXsltTask) {
    input xsl
    stylesheet xsl
    dependsOn tasks.named('makeXslt')
    output "${buildDir}/xspec/${base}.xspec"
  }

  def t = project.tasks.register("${taskname}", Exec) {
    inputs.files fileTree(dir: "${projectDir}/src/main/xslt")
    inputs.files fileTree(dir: "${projectDir}/src/test/xspec")
    inputs.files fileTree(dir: "${projectDir}/src/test/resources")
    inputs.file "${buildDir}/xspec/${base}.xspec"
    outputs.file project.file("${buildDir}/${base}-compiled.xsl")
    outputs.file project.file("${buildDir}/${base}-result.html")
    outputs.file project.file("${buildDir}/${base}-result.xml")
    dependsOn g
    dependsOn tasks.named('setupXSpec')
    dependsOn tasks.named('makeXslt')

    commandLine "${buildDir}/xspec-${xspecVersion}/bin/${XSPEC}",
                "${fBuildDir}/xspec/${base}.xspec"
  }
  tasks.named("xspecTests").configure {
    dependsOn t
  }
}

// ============================================================

task dbtransform(type: SaxonXsltTask, dependsOn: ['makeXslt']) {
  outputs.upToDateWhen { false }
  doFirst {
    if (dbsource = '') {
      throw new GradleException("You must specify -Pdbsource=...")
    }
    if (dboutput = '') {
      throw new GradleException("You must specify -Pdboutput=...")
    }
  }

  def ssparams = [:]
  if (dbparams.trim() != "") {
    dbparams.split(/\s+/).each { param ->
      def pos = param.indexOf('=')
      if (pos <= 0) {
        throw new GradleException("Malformed parameter: ${param}")
      } else {
        def name = param.substring(0, pos).replace(/%20/, ' ')
        def value = param.substring(pos+1).replace(/%20/, ' ')
        ssparams[name] = value
      }
    }
  }

  def xslt = "${buildDir}/xslt/docbook.xsl"
  if (dbstyle != '') {
    xslt = dbstyle
  }

  input "${dbsource}"
  stylesheet "${xslt}"
  args docbookXsltArgs

  if (dboutput != '-') {
    output "${dboutput}"
  }

  parameters(ssparams)
}

task helloWorld() {
  doLast {
    println('Hello, world')

/*
    configurations.validateRuntime.each { path ->
      println("CP: ${path}")
    }
    configurations.projectRuntimeClasspath.each { path ->
      println("R: ${path}")
    }
    configurations.projectImplementationClasspath.each { path ->
      println("I: ${path}")
    }
    configurations.compileClasspath.each { cp ->
      println("CCP: ${cp}")
    }
    println("${EXCP}")
*/
  }
}
